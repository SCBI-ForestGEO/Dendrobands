rings <- read.rwl(file) #read in rwl file
area <- bai.in(rings) #convert to bai.in
test <- res.comp(area, nb.yrs=5, res.thresh.neg = 20, series.thresh = 50) #get resilience metrics
subcanopy[[i]] <- test
test_table <- data.frame(test$out)
test_table <- test_table[test_table$nb.series > 4, ] #remove where there are < 4 series
test_table$sp <- sp_subcan[[j]]
test_table$position <- "subcanopy"
subcanopy_table <- rbind(subcanopy_table, test_table)
}
values_sub <- paste0(sp_subcan, "_subcan_res")
names(subcanopy) <- values_sub
##4c. df for pointer years of all trees combined ####
full_ind <- rbind(canopy_table, subcanopy_table) #full table of indices for canopy and subcanopy cores
pointers <- full_ind[full_ind$nature == -1, ]
library(dplyr)
years_point <- count(pointers, vars=year) #counts the occurrences of each unique year
colnames(years_point) <- c("yr", "n.pointer")
years_point <- years_point[order(years_point$n.pointer, decreasing=TRUE), ]
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/tree-growth-and-traits")
write.csv(pointers, "occurrence_of_pointer_yrs.csv", row.names=FALSE)
##4d. resistance metrics for all trees ####
neil_list <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/tree-growth-and-traits/core_list_for_neil.csv", stringsAsFactors = FALSE)
neil_list$tag <- paste0("X", neil_list$tag) #to match the colnames of can_resist below
pointer_years <- years_point$yr[1:6] #from above in #3c
##canopy ####
#this loop says, for the different species in the list "canopy" (names(canopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(canopy)
trees_canopy <- NULL
for (i in seq(along=1:length(tag_n))){
can_resist <- data.frame(canopy[[i]]$resist)
years <- rownames(can_resist)
colnames(can_resist) <- gsub("A", "", colnames(can_resist))
tree_series <- colnames(can_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- can_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "canopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_canopy <- rbind(trees_canopy, change)
}
##subcanopy ####
#this loop says, for the different species in the list "subcanopy" (names(subcanopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(subcanopy)
trees_subcanopy <- NULL
for (i in seq(along=1:length(tag_n))){
sub_resist <- data.frame(subcanopy[[i]]$resist)
years <- rownames(sub_resist)
colnames(sub_resist) <- gsub("A", "", colnames(sub_resist))
tree_series <- colnames(sub_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- sub_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "subcanopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_subcanopy <- rbind(trees_subcanopy, change)
}
##rbind together ####
trees_all <- rbind(trees_canopy, trees_subcanopy)
##############################################################################################
#5. mixed effects model for output of #4. ####
library(lme4)
library(AICcmodavg)
##5a. Determine best model to use ####
#resist.value is response variable, position is a fixed effect, year and species are random effects
lmm <- lmer(resist.value ~ position + (1 | sp) + (1 | year), data=trees_all, REML=FALSE)
summary(lmm)
#all_models_aic <- NULL
#for (i in seq(along=trees_all$tree)){
#  tr <- trees_all$tree[[i]]
#  trees_subset <- trees_all[trees_all$tree == tr, ]
lmm.nullsp <- lmer(resist.value ~ 1 + (1 | sp), data=trees_all, REML=FALSE)
lmm.nullyear <- lmer(resist.value ~ 1 + (1 | year), data=trees_all, REML=FALSE)
lmm.random <- lmer(resist.value ~ 1 + (1 | sp) + (1 | year), data=trees_all, REML=FALSE)
lmm.positionsp <- lmer(resist.value ~ position + (1 | sp), data=trees_all, REML=FALSE)
lmm.positionyear <- lmer(resist.value ~ position + (1 | year), data=trees_all, REML=FALSE)
lmm.full <- lmer(resist.value ~ position + (1 | sp) + (1 | year), data=trees_all, REML=FALSE)
cand.models <- list(lmm.nullsp, lmm.nullyear, lmm.random, lmm.positionsp, lmm.positionyear, lmm.full)
names(cand.models) <- c("lmm.nullsp", "lmm.nullyear", "lmm.random", "lmm.positionsp", "lmm.positionyear", "lmm.full")
#this function looks through all the models above to say what is the best one (what fits the best)
var_aic <- aictab(cand.models, second.ord=TRUE, sort=TRUE)
#  var_aic$tree <- tr
#  all_models_aic <- rbind(all_models_aic, var_aic)
#}
#subset by only the top result (the minimum AICc value)
aic_top <- var_aic %>%
filter(AICc == min(AICc))
##5b. Run the best model, changing REML to TRUE ####
library(car)
lmm.full <- lmm.full <- lmer(resist.value ~ position + (1 | sp) + (1 | year), data=trees_all)
vari_anova <- Anova(lmm.full)
q <- qqp(residuals(lmm.full), "norm", main="resistance_residuals")
print(q)
View(aic_top)
pointer_years
View(years_point)
View(vari_anova)
#4. finding pointer years and resistance metrics ####
library(pointRes)
library(dplR)
library(data.table)
##4a. canopy ####
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/canopy_cores")
dirs_can <- dir("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/canopy_cores", pattern = "_canopy.rwl")
dirs_can <- dirs_can[dirs_can != "frni_canopy.rwl" & dirs_can != "frni_drop_canopy.rwl" & dirs_can != "caco_drop_canopy.rwl"]
sp_can <- gsub("_drop_canopy.rwl", "", dirs_can)
canopy <- list()
canopy_table <- NULL
for (i in seq(along=dirs_can)){
for (j in seq(along=sp_can)){
if (i==j){
file <- dirs_can[[i]]
rings <- read.rwl(file) #read in rwl file
area <- bai.in(rings) #convert to bai.in
testr <- res.comp(area, nb.yrs=5, res.thresh.neg = 40, series.thresh = 50) #get resilience metrics
canopy[[i]] <- testr
testr_table <- data.frame(testr$out)
testr_table <- testr_table[testr_table$nb.series > 4, ] #remove where there are < 4 series
testr_table$sp <- sp_can[[j]]
testr_table$position <- "canopy"
canopy_table <- rbind(canopy_table, testr_table)
}
values <- paste0(sp_can, "_can_res")
names(canopy) <- values
##4b. subcanopy ####
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/subcanopy_cores")
dirs_subcan <- dir("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/subcanopy_cores", pattern = "_subcanopy.rwl")
dirs_subcan <- dirs_subcan[dirs_subcan != "frni_drop_subcanopy.rwl" & dirs_subcan != "caco_drop_subcanopy.rwl"]
sp_subcan <- gsub("_drop_subcanopy.rwl", "", dirs_subcan)
subcanopy <- list()
subcanopy_table <- NULL
for (i in seq(along=dirs_subcan)){
for (j in seq(along=sp_subcan)){
if (i==j){
file <- dirs_subcan[[i]]
rings <- read.rwl(file) #read in rwl file
area <- bai.in(rings) #convert to bai.in
test <- res.comp(area, nb.yrs=5, res.thresh.neg = 40, series.thresh = 50) #get resilience metrics
subcanopy[[i]] <- test
test_table <- data.frame(test$out)
test_table <- test_table[test_table$nb.series > 4, ] #remove where there are < 4 series
test_table$sp <- sp_subcan[[j]]
test_table$position <- "subcanopy"
subcanopy_table <- rbind(subcanopy_table, test_table)
}
values_sub <- paste0(sp_subcan, "_subcan_res")
names(subcanopy) <- values_sub
##4c. df for pointer years of all trees combined ####
full_ind <- rbind(canopy_table, subcanopy_table) #full table of indices for canopy and subcanopy cores
pointers <- full_ind[full_ind$nature == -1, ]
library(dplyr)
years_point <- count(pointers, vars=year) #counts the occurrences of each unique year
colnames(years_point) <- c("yr", "n.pointer")
years_point <- years_point[order(years_point$n.pointer, decreasing=TRUE), ]
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/tree-growth-and-traits")
write.csv(pointers, "occurrence_of_pointer_yrs.csv", row.names=FALSE)
##4d. resistance metrics for all trees ####
neil_list <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/tree-growth-and-traits/core_list_for_neil.csv", stringsAsFactors = FALSE)
neil_list$tag <- paste0("X", neil_list$tag) #to match the colnames of can_resist below
pointer_years <- years_point$yr[1:6] #from above in #3c
##canopy ####
#this loop says, for the different species in the list "canopy" (names(canopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(canopy)
trees_canopy <- NULL
for (i in seq(along=1:length(tag_n))){
can_resist <- data.frame(canopy[[i]]$resist)
years <- rownames(can_resist)
colnames(can_resist) <- gsub("A", "", colnames(can_resist))
tree_series <- colnames(can_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- can_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "canopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_canopy <- rbind(trees_canopy, change)
}
##subcanopy ####
#this loop says, for the different species in the list "subcanopy" (names(subcanopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(subcanopy)
trees_subcanopy <- NULL
for (i in seq(along=1:length(tag_n))){
sub_resist <- data.frame(subcanopy[[i]]$resist)
years <- rownames(sub_resist)
colnames(sub_resist) <- gsub("A", "", colnames(sub_resist))
tree_series <- colnames(sub_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- sub_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "subcanopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_subcanopy <- rbind(trees_subcanopy, change)
}
##rbind together ####
trees_all <- rbind(trees_canopy, trees_subcanopy)
##############################################################################################
#5. mixed effects model for output of #4. ####
library(lme4)
library(AICcmodavg)
##5a. Determine best model to use ####
#resist.value is response variable, position is a fixed effect, year and species are random effects
lmm <- lmer(resist.value ~ position + (1 | sp) + (1 | year), data=trees_all, REML=FALSE)
summary(lmm)
#all_models_aic <- NULL
#for (i in seq(along=trees_all$tree)){
#  tr <- trees_all$tree[[i]]
#  trees_subset <- trees_all[trees_all$tree == tr, ]
lmm.nullsp <- lmer(resist.value ~ 1 + (1 | sp), data=trees_all, REML=FALSE)
lmm.nullyear <- lmer(resist.value ~ 1 + (1 | year), data=trees_all, REML=FALSE)
lmm.random <- lmer(resist.value ~ 1 + (1 | sp) + (1 | year), data=trees_all, REML=FALSE)
lmm.positionsp <- lmer(resist.value ~ position + (1 | sp), data=trees_all, REML=FALSE)
lmm.positionyear <- lmer(resist.value ~ position + (1 | year), data=trees_all, REML=FALSE)
lmm.full <- lmer(resist.value ~ position + (1 | sp) + (1 | year), data=trees_all, REML=FALSE)
cand.models <- list(lmm.nullsp, lmm.nullyear, lmm.random, lmm.positionsp, lmm.positionyear, lmm.full)
names(cand.models) <- c("lmm.nullsp", "lmm.nullyear", "lmm.random", "lmm.positionsp", "lmm.positionyear", "lmm.full")
#this function looks through all the models above to say what is the best one (what fits the best)
var_aic <- aictab(cand.models, second.ord=TRUE, sort=TRUE)
#  var_aic$tree <- tr
#  all_models_aic <- rbind(all_models_aic, var_aic)
#}
#subset by only the top result (the minimum AICc value)
aic_top <- var_aic %>%
filter(AICc == min(AICc))
##5b. Run the best model, changing REML to TRUE ####
library(car)
lmm.full <- lmm.full <- lmer(resist.value ~ position + (1 | sp) + (1 | year), data=trees_all)
vari_anova <- Anova(lmm.full)
q <- qqp(residuals(lmm.full), "norm", main="resistance_residuals")
print(q)
View(years_point)
View(vari_anova)
#4. finding pointer years and resistance metrics ####
library(pointRes)
library(dplR)
library(data.table)
##4a. canopy ####
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/canopy_cores")
dirs_can <- dir("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/canopy_cores", pattern = "_canopy.rwl")
dirs_can <- dirs_can[dirs_can != "frni_canopy.rwl" & dirs_can != "frni_drop_canopy.rwl" & dirs_can != "caco_drop_canopy.rwl"]
sp_can <- gsub("_drop_canopy.rwl", "", dirs_can)
canopy <- list()
canopy_table <- NULL
for (i in seq(along=dirs_can)){
for (j in seq(along=sp_can)){
if (i==j){
file <- dirs_can[[i]]
rings <- read.rwl(file) #read in rwl file
area <- bai.in(rings) #convert to bai.in
testr <- res.comp(area, nb.yrs=5, res.thresh.neg = 30, series.thresh = 50) #get resilience metrics
canopy[[i]] <- testr
testr_table <- data.frame(testr$out)
testr_table <- testr_table[testr_table$nb.series > 4, ] #remove where there are < 4 series
testr_table$sp <- sp_can[[j]]
testr_table$position <- "canopy"
canopy_table <- rbind(canopy_table, testr_table)
}
values <- paste0(sp_can, "_can_res")
names(canopy) <- values
##4b. subcanopy ####
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/subcanopy_cores")
dirs_subcan <- dir("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/subcanopy_cores", pattern = "_subcanopy.rwl")
dirs_subcan <- dirs_subcan[dirs_subcan != "frni_drop_subcanopy.rwl" & dirs_subcan != "caco_drop_subcanopy.rwl"]
sp_subcan <- gsub("_drop_subcanopy.rwl", "", dirs_subcan)
subcanopy <- list()
subcanopy_table <- NULL
for (i in seq(along=dirs_subcan)){
for (j in seq(along=sp_subcan)){
if (i==j){
file <- dirs_subcan[[i]]
rings <- read.rwl(file) #read in rwl file
area <- bai.in(rings) #convert to bai.in
test <- res.comp(area, nb.yrs=5, res.thresh.neg = 30, series.thresh = 50) #get resilience metrics
subcanopy[[i]] <- test
test_table <- data.frame(test$out)
test_table <- test_table[test_table$nb.series > 4, ] #remove where there are < 4 series
test_table$sp <- sp_subcan[[j]]
test_table$position <- "subcanopy"
subcanopy_table <- rbind(subcanopy_table, test_table)
}
values_sub <- paste0(sp_subcan, "_subcan_res")
names(subcanopy) <- values_sub
##4c. df for pointer years of all trees combined ####
full_ind <- rbind(canopy_table, subcanopy_table) #full table of indices for canopy and subcanopy cores
pointers <- full_ind[full_ind$nature == -1, ]
library(dplyr)
years_point <- count(pointers, vars=year) #counts the occurrences of each unique year
colnames(years_point) <- c("yr", "n.pointer")
years_point <- years_point[order(years_point$n.pointer, decreasing=TRUE), ]
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/tree-growth-and-traits")
write.csv(pointers, "occurrence_of_pointer_yrs.csv", row.names=FALSE)
##4d. resistance metrics for all trees ####
neil_list <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/tree-growth-and-traits/core_list_for_neil.csv", stringsAsFactors = FALSE)
neil_list$tag <- paste0("X", neil_list$tag) #to match the colnames of can_resist below
pointer_years <- years_point$yr[1:6] #from above in #3c
##canopy ####
#this loop says, for the different species in the list "canopy" (names(canopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(canopy)
trees_canopy <- NULL
for (i in seq(along=1:length(tag_n))){
can_resist <- data.frame(canopy[[i]]$resist)
years <- rownames(can_resist)
colnames(can_resist) <- gsub("A", "", colnames(can_resist))
tree_series <- colnames(can_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- can_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "canopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_canopy <- rbind(trees_canopy, change)
}
##subcanopy ####
#this loop says, for the different species in the list "subcanopy" (names(subcanopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(subcanopy)
trees_subcanopy <- NULL
for (i in seq(along=1:length(tag_n))){
sub_resist <- data.frame(subcanopy[[i]]$resist)
years <- rownames(sub_resist)
colnames(sub_resist) <- gsub("A", "", colnames(sub_resist))
tree_series <- colnames(sub_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- sub_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "subcanopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_subcanopy <- rbind(trees_subcanopy, change)
}
##rbind together ####
trees_all <- rbind(trees_canopy, trees_subcanopy)
##############################################################################################
#5. mixed effects model for output of #4. ####
library(lme4)
library(AICcmodavg)
library(car)
##5a. Determine best model to use ####
#resist.value is response variable, position is a fixed effect, year and species are random effects
lmm <- lmer(resist.value ~ position + (1 | sp) + (1 | year), data=trees_all, REML=FALSE)
summary(lmm)
#all_models_aic <- NULL
#for (i in seq(along=trees_all$tree)){
#  tr <- trees_all$tree[[i]]
#  trees_subset <- trees_all[trees_all$tree == tr, ]
lmm.nullsp <- lmer(resist.value ~ 1 + (1 | sp), data=trees_all, REML=FALSE)
lmm.nullyear <- lmer(resist.value ~ 1 + (1 | year), data=trees_all, REML=FALSE)
lmm.random <- lmer(resist.value ~ 1 + (1 | sp) + (1 | year), data=trees_all, REML=FALSE)
lmm.positionsp <- lmer(resist.value ~ position + (1 | sp), data=trees_all, REML=FALSE)
lmm.positionyear <- lmer(resist.value ~ position + (1 | year), data=trees_all, REML=FALSE)
lmm.full <- lmer(resist.value ~ position + (1 | sp) + (1 | year), data=trees_all, REML=FALSE)
cand.models <- list(lmm.nullsp, lmm.nullyear, lmm.random, lmm.positionsp, lmm.positionyear, lmm.full)
names(cand.models) <- c("lmm.nullsp", "lmm.nullyear", "lmm.random", "lmm.positionsp", "lmm.positionyear", "lmm.full")
#this function looks through all the models above to say what is the best one (what fits the best)
var_aic <- aictab(cand.models, second.ord=TRUE, sort=TRUE)
#  var_aic$tree <- tr
#  all_models_aic <- rbind(all_models_aic, var_aic)
#}
#subset by only the top result (the minimum AICc value)
aic_top <- var_aic %>%
filter(AICc == min(AICc))
##5b. Run the best model, changing REML to TRUE ####
lmm.full <- lmm.full <- lmer(resist.value ~ position + (1 | sp) + (1 | year), data=trees_all)
vari_anova <- Anova(lmm.full)
q <- qqp(residuals(lmm.full), "norm", main="resistance_residuals")
print(q)
View(vari_anova)
Anova(lmm.full)
View(vari_anova)
summary(lmm.full)
View(trees_all)
?boxplot
boxplot(resist.value ~ position, data=trees_all)
library(ggplot2)
ggplot(trees_all, aes(x=resist.value)) +
geom_density() +
face_wrap(position)
ggplot(trees_all, aes(x=resist.value)) +
geom_density() +
facet_wrap(position)
ggplot(trees_all, aes(x=resist.value)) +
geom_density() +
facet_wrap(trees_all$position)
ggplot(trees_all, aes(x=resist.value)) +
geom_density() +
facet_wrap()
ggplot(trees_all, aes(x=resist.value)) +
geom_density()
?facet_wrap
ggplot(trees_all, aes(x=resist.value)) +
geom_density() +
facet_wrap(position ~ year)
plot(fitted(lmm.full), residuals(lmm.full), xlab = "Fitted Values", ylab = "Residuals")
abline(h=0, lty=2)
lines(smooth.spline(fitted(lmm.full), residuals(lmm.full)))
?summary
?anova
anova(cand.models)
anova(cand.models[1:6])
anova(cand.models[[1:6]])
anova(cand.models[[1]])
anova(lmm.nullsp, lmm.nullyear, lmm.random, lmm.positionsp, lmm.positionyear, lmm.full)
View(aic_top)
range(trees_all$resist.value)
range(trees_all$resist.value, na.rm=TRUE)
?aov
?lm
summary(lmm.full)
#this plot shows the distribution of resistance values for each pointer year for each canopy position. It clearly shows how canopy/subcanopy differ
ggplot(trees_all, aes(x=resist.value)) +
geom_density() +
facet_wrap(position ~ year)
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data")
dirs <- dir("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data", pattern="_201[0-8]*.csv")
years <- c(2010:2018)
#1a. this loop breaks up each year's dendroband trees into separate dataframes by stemID ####
all_years <- list()
for (k in seq(along=dirs)){
file <- dirs[[k]]
yr <- read.csv(file, stringsAsFactors = FALSE)
yr_intra <- yr[yr$intraannual==1, ]
yr_intra$dbh <- as.numeric(yr_intra$dbh)
all_years[[k]] <- split(yr_intra, yr_intra$stemID)
#  if (file == dirs[[1]]){
#   all_years[[k]] <- split(yr, yr$stemID)
#  }
#  else{
#    all_years[[k]] <- split(yr_intra, yr_intra$stemID)
#  }
}
tent_name <- paste0("trees", sep="_", years)
names(all_years) <- tent_name
#the below loop takes all the unique stemIDs from each year and rbinds them.
all_stems <- list()
for(stemID in sort(unique(unlist(sapply(all_years, names))))) {
all_stems[[paste0("stemID_", stemID)]] <-  do.call(rbind, lapply(years, function(year) all_years[[paste0("trees", sep="_", year)]][[stemID]]))
}
devtools::install_github("seanmcm/RDendrom")
library(RDendrom)
test_intra <- all_stems$stemID_10045
library(data.table)
test_intra <- setnames(test_intra,
old=c("treeID", "dendroID", "stemID", "sp", "dbh", "measure", "year", "new.band"),
new=c("TREE_ID", "BAND_NUM", "UNIQUE_ID", "SP", "ORG_DBH", "GAP_WIDTH", "YEAR", "NEW_BAND"))
newcols <- c("SKIP", "ADJUST", "REMOVE")
test_intra[,newcols] <- 0
test_intra$SITE <- "SCBI"
test_intra$ORG_DBH <- test_intra$ORG_DBH/10
library(lubridate)
test_intra$DOY <- as.Date(with(test_intra, paste(YEAR, month, day, sep="-")), "%Y-%m-%d")
test_intra$DOY <- yday(test_intra$DOY)
test_intra$SITE <- "SCBI"
get.optimized.dendro(test_intra, units="cm", OUTPUT.folder = "C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/results/McMahon_code_output")
write.csv(test_intra, "tree_10045.csv", row.names=FALSE)
test_intra <- all_stems$stemID_7444
library(data.table)
test_intra <- setnames(test_intra,
old=c("treeID", "dendroID", "stemID", "sp", "dbh", "measure", "year", "new.band"),
new=c("TREE_ID", "BAND_NUM", "UNIQUE_ID", "SP", "ORG_DBH", "GAP_WIDTH", "YEAR", "NEW_BAND"))
newcols <- c("SKIP", "ADJUST", "REMOVE")
test_intra[,newcols] <- 0
test_intra$SITE <- "SCBI"
test_intra$ORG_DBH <- test_intra$ORG_DBH/10
library(lubridate)
test_intra$DOY <- as.Date(with(test_intra, paste(YEAR, month, day, sep="-")), "%Y-%m-%d")
test_intra$DOY <- yday(test_intra$DOY)
test_intra$SITE <- "SCBI"
get.optimized.dendro(test_intra, units="cm", OUTPUT.folder = "C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/results/McMahon_code_output")
write.csv(test_intra, "tree_7444.csv", row.names=FALSE)
