##order the data and remove the crossovers (btwn biannual and cored) that don't have biannual marked already
dendro_all <- dendro_all[order(dendro_all$tag,dendro_all$biannual),]
dendro_all$stemID[is.na(dendro_all$stemID)] <- 0
##WARNING:assign stemID values for 30365 and 131352 (discrepancy with 2013 census). THIS PART SHOULD BE DELETED once the 2018 census data includes these tags with the appropriate info.
dendro_all[91,6]=11
dendro_all[867,6]=12
dendro_all<-dendro_all[!duplicated(dendro_all$stemID),]
##populate with geographic coordinates
latlon <- read.csv("V:/SIGEO/GIS_data/dendroband surveys/Merged_dendroband_utm_lat_lon.csv")
dendro_all$NAD83_X <- latlon$NAD83_X[match(dendro_all$stemID, latlon$stemID)]
dendro_all$NAD83_Y <- latlon$NAD83_Y[match(dendro_all$stemID, latlon$stemID)]
dendro_all$lat <- latlon$lat[match(dendro_all$stemID, latlon$stemID)]
dendro_all$lon <- latlon$lon[match(dendro_all$stemID, latlon$stemID)]
##populate with lx, ly, and status (once ForestGEO 2018 census data is added, use that for base status)
census_2013 <- read.csv("V:/SIGEO/3-RECENSUS 2013/DATA/FINAL DATA to use, to share/scbi.stem2.csv")
dendro_all$lx <- $lx[match(dendro_all$stemID, $stemID)]
dendro_all$ly <- $ly[match(dendro_all$stemID, $stemID)]
##update status from most recent mortality data (this will update only some of the trees, hence why the census data is used first)
mortality_2018 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data_private/SCBI_mortality/raw data/Mortality_Survey_2018.csv")
dendro_all$status <- mortality_2018$new.status[match(dendro_all$tag, mortality_2018$tag)]
missing <- ifelse(is.na(dendro_all$status), dendro_all$tag, "")
missingdf <- dendro_all[!complete.cases(dendro_all$status),]
missingdf <- missingdf[c(1:2)]
setnames(census_2013, old=c("StemTag"), new=c("stemtag"))
dendro_test <- merge(missingdf, census_2013[,c("tag", "stemtag","status")], by=c("tag","stemtag"))
dendro_all <- merge(dendro_all, dendro_test, by="tag", all.x=TRUE)
setnames(dendro_all, old="stemtag.x", new="stemtag")
library(tidyr)
dendro_all <- unite(dendro_all, status, status.x, status.y)
dendro_all$status <- gsub("_NA", "", dendro_all$status)
dendro_all$status <- gsub("NA_", "", dendro_all$status)
dendro_all$status <- gsub("PD", "D", dendro_all$status)
dendro_all$status <- gsub("DS", "D", dendro_all$status)
dendro_all$status <- gsub("DC", "D", dendro_all$status)
dendro_all$status <- gsub("AU", "A", dendro_all$status)
##get rid of NA
dendro_all$biannual[is.na(dendro_all$biannual)] <- 0
dendro_all$intraannual[is.na(dendro_all$intraannual)] <- 0
dendro_all$cored[is.na(dendro_all$cored)] <- 1
##re-order
dendro_all <- dendro_all[c(1:6,11:13,10,7,14:15,8:9,16:19)]
#get rid of final duplicates now that all rows are the same
dendro_all <- dendro_all[!duplicated(dendro_all),]
write.csv(dendro_all, "dendro_cored_full.csv", row.names=FALSE)
getwd()
dendro_cored_full <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/clean_data_files/dendro_cored_full.csv")
View(dendro_cored_full)
library(dplyr)
dendro <- dendro_cored_full %>%
filter(status==A)
dendro <- dendro_cored_full %>%
filter(status=="A")
View(dendro)
dendro <- dendro[c(1:4,7:11)]
View(dendro)
dendro <- dendro[c(1:4,7:10)]
dendro <- dendro_cored_full %>%
filter(status=="A")
dendro <- dendro[c(1:4,7:10)]
View(dendro)
dendro$crown.position <- ""
View(dendro)
write.csv(dendro, "scbi.crownposition.csv")
getwd()
install.packages(devtools)
install.packages("devtools")
devtools::install_github("forestgeo/fgeo")
library(fgeo)
devtools::install_github("forestgeo/fgeo")
library(fgeo)
fgeo(help)
install.packages(c("animation", "aqp", "backports", "BH", "bookdown", "broom", "callr", "carData", "checkmate", "classInt", "clipr", "colorspace", "curl", "data.table", "dbplyr", "dplR", "dplyr", "e1071", "esquisse", "expss", "flextable", "FNN", "ggmap", "ggvis", "git2r", "googleVis", "haven", "Hmisc", "htmlTable", "htmlwidgets", "httpuv", "httr", "jsonlite", "lemon", "lme4", "mapview", "markdown", "measurements", "mgcv", "nloptr", "openssl", "packrat", "pillar", "plotKML", "processx", "ps", "psych", "purrr", "quantreg", "raster", "rcmdcheck", "Rcpp", "RcppEigen", "readr", "readxl", "reshape", "rio", "RJSONIO", "rlang", "rmarkdown", "rsconnect", "rstudioapi", "sessioninfo", "sf", "shiny", "shinyWidgets", "spam", "spData", "stars", "testthat", "tibble", "tidybayes", "tinytex", "tmap", "units", "waveslim", "webshot", "writexl", "xts"))
install.packages("pupR")
dendro2011 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/scbi.dendroAll_2011.csv")
dendro2012 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/scbi.dendroAll_2012.csv")
View(dendro2011)
View(dendro2012)
dendro2012 <- dendro2012[dendro2012$new.band==1, ]
farms <- data.frame(lat=runif(3), lng=runif(3))
dist(farms, diag=T, upper=T)
#behold the vegan package
farms <- data.frame(lat=runif(20), lng=runif(20))
View(farms)
rownames(farms) <- "A:Z"
rownames(farms) <- "[[:alpha:]]"
"[[:alpha:]]"
[[:alpha:]]
[:alpha:]
rownames(farms) <- 180001:180026
rownames(farms) <- 180001:180027
#behold the vegan package
farms <- data.frame(lat=runif(26), lng=runif(26))
rownames(farms) <- 180001:180026
View(farms)
d <- vegdist(farms, method="euclidean") #caluclate distance
#behold the vegan package
library(vegan)
d <- vegdist(farms, method="euclidean") #caluclate distance
m <- data.frame(t(combn(rownames(farms),2)), as.numeric(d)) #put in df format
names(m) <- c("tree1", "tree2", "distance")
View(m)
scbi.full2 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_main_census/data/census-csv-files/scbi.full2.csv", stringsAsFactors=FALSE)
scbi.full2[5340, 3] <- 40874 #duplicated tag
trees <- scbi.full2[scbi.full2$dbh>=100  & !grepl("S", scbi.full2$codes), ]
trees <- trees[c(3,7,8)]
rownames(trees) <- trees[,1]
trees <- trees[, -1]
library(vegan)
d <- vegdist(trees, method="euclidean") #calculate distance between one tree and all the other trees using Pythagorean theorem
m <- data.frame(t(combn(rownames(trees),2)), as.numeric(d)) #put in df format
names(m) <- c("tree1", "tree2", "distance")
simple <- m[m$distance<=30, ] #only include distances of 30m or less
simple <- simple[sort(simple$tree1, simple$distance)]
?sort
?order
simple <- simple[order(simple$tree1, simple$distance)]
simple <- simple[order(simple$tree1, simple$distance), ]
View(simple)
scbi.2013 <- scbi.full2[scbi.full2$tag %in% unique(simple$tree1), ]
setdiff(unique(simple$tree1), scbi.2013$tag)
unique(simple$tree1)
q <- unique(simple$tree1)
p <- scbi.2013[duplicated(scbi.2013$tag)]
p <- scbi.2013[duplicated(scbi.2013$tag), ]
View(p)
scbi.sub <- scbi.full2[scbi.full2$dbh>=100  & !grepl("S", scbi.full2$codes), ]
trees <- scbi.sub[c(3,7,8)]
rownames(trees) <- trees[,1]
trees <- trees[, -1]
scbi.sub <- scbi.sub[scbi.sub$tag %in% unique(simple$tree1), ]
p <- trees[duplicated(rownames(trees)), ]
setdiff(unique(simple$tree1), scbi.sub$tag)
View(trees)
rm(scbi.2013)
scbi.full2 <- scbi.full2[scbi.full2$dbh>=100  & !grepl("S", scbi.full2$codes), ]
trees <- scbi.full2[c(3,7,8)]
rownames(trees) <- trees[,1]
trees <- trees[, -1]
scbi.sub <- scbi.full2[scbi.full2$tag %in% unique(simple$tree1), ] #this number won't match "trees" because some trees from scbi.sub are >30m apart from another tree
View(simple)
View(scbi.sub)
scbi.sub <- scbi.sub[c(3,7,8,11)]
scbi.sub$basal <- pi*(scbi.sub$dbh/2)^2
View(scbi.sub)
scbi.sub$dbh <- scbi.sub$dbh/10
View(scbi.sub)
scbi.sub$basal <- pi*(scbi.sub$dbh/2)^2
View(scbi.sub)
?seq
seq(1,30, by=0.5)
seq(0,30, by=0.5)
dist <- seq(0,30, by=0.5)
scbi.sub[, dist] <- NA
scbi.sub[dist] <- NA
?rep
gsub("^", "X", dist)
gsub("^", "x", dist)
dist <- gsub("^", "x", dist)
scbi.sub[, dist] <- NA
View(scbi.sub)
scbi.sub$basal <- (pi*(scbi.sub$dbh/2)^2)*0.0001
View(scbi.sub)
View(m)
View(simple)
test <- simple[simple$tree1 == 12165, ]
View(test)
test <- simple[simple$tree1 == 12165 | simple$tree2 == 12165, ]
View(test)
sum(test$distance)
sum(test$distance) / 30
scbi.sub[scbi.sub$tag==12171, ]
scbi.sub[scbi.sub$tag==12173, ]
colnames(scbi.sub[, 6:ncol(scbi.sub)])
i=1
inc <- colnames(scbi.sub[, 6:ncol(scbi.sub)])[[i]]
inc <- gsub("x", "", inc)
inc <- colnames(scbi.sub[, 6:ncol(scbi.sub)])[[i]]
inc_num <- gsub("x", "", inc)
j=1
test <- simple[simple$tree1 | simple$tree2 == simple$tree1[[j]], ]
simple$tree1 <- as.numeric(simple$tree1)
simple$tree2 <- as.numeric(simple$tree2)
test <- simple[simple$tree1 | simple$tree2 == simple$tree1[[j]], ]
test <- simple[simple$tree1 == simple$tree[[j]] | simple$tree2 == simple$tree1[[j]], ]
simple$tree1
simple <- m[m$distance<=30, ] #only include distances of 30m or less
simple <- simple[order(simple$tree1, simple$distance), ] #sort by tree and distance
simple$tree1 <- as.character(simple$tree1)
View(simple)
simple$tree2 <- as.character(simple$tree2)
View(simple)
simple$tree2 <- as.numeric(simple$tree2)
simple$tree1 <- as.numeric(simple$tree1)
View(simple)
test <- simple[simple$tree1 == simple$tree[[j]] | simple$tree2 == simple$tree1[[j]], ]
simple$tree1
tree <- unique(simple$tree1)[[j]]
test <- simple[simple$tree1 == tree | simple$tree2 == tree, ]
View(test)
test <- test[order(test$distance), ] #order by distance
View(test)
test$distance
test$distance[-ncol(test)]
inc <- colnames(scbi.sub[, 6:ncol(scbi.sub)])[[i]]
scbi.sub$inc
colnames(scbi.sub)
inc <- colnames(scbi.sub) # [, 6:ncol(scbi.sub)])[[i]]
inc <- colnames(scbi.sub)[[i]] # [, 6:ncol(scbi.sub)])[[i]]
inc[[i>=6]]
i=2
inc <- colnames(scbi.sub)[[i]] # [, 6:ncol(scbi.sub)])[[i]]
inc-1
inc[-1]
inc <- colnames(scbi.sub)[[i-1]] # [, 6:ncol(scbi.sub)])[[i]]
k=1
inc_num <- colnames(scbi.sub[, 6:ncol(scbi.sub)])[[k]]
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/")
data_2019 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/scbi.dendroAll_2019.csv")
data_biannual <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/data_entry_forms/2019/data_entry_biannual_spr2019.csv")
names2019 <- c(colnames(data_2019))
namesbi <- c(colnames(data_biannual))
## find the names that are in data_2019 but not in data_biannual
missing <- setdiff(names2019, namesbi)
## if need be, do the opposite
# missing <- setdiff(namesbi, names2019)
## add these missed names to data_biannual in order to combine to the master
data_biannual[missing] <- NA
data_biannual$area <- NULL #this column is only relevant for field
test <- rbind(data_2019, data_biannual)
test <- test[order(test[,1], test[,3], test[,2]), ] #order by tag and survey.ID
View(test)
?sort
test <- test[order(test[,1], test[,3], test[,2], na.last=FALSE), ] #order by tag and survey.ID
test <- test[order(test$tag, test$stemtag, test$survey.ID, na.last=FALSE), ] #order by tag and survey.ID
test$biannual <- ifelse(is.na(test$biannual) & test$tag == lag(test$tag), na.locf(test$biannual), test$biannual)
## these values are constant from the previous survey.ID
library(zoo)
library(dplyr)
test$biannual <- ifelse(!is.na(test$survey.ID) & is.na(lead(test$survey.ID)) & is.na(test$biannual), lead(test$biannual), test$biannual)
test <- rbind(data_2019, data_biannual)
test <- test[order(test$tag, test$stemtag, test$survey.ID, na.last=FALSE), ]
test$biannual <- ifelse(is.na(test$biannual) & test$tag == lag(test$tag), na.locf(test$biannual), test$biannual)
test$biannual
is.na(test$biannual)
cols <- c("biannual", "intraannual", "lx", "ly", "stemID", "treeID", "dbh", "new.band", "dendroID", "type", "dendHt")
i=1
test$cols[[i]]
fix <- paste0("test$", cols[[i]])
fix
fix <- paste0(test$, cols[[i]])
cols[[i]]
fix <- cols[[i]]
test$fix
cols <- c("test$biannual", "intraannual", "lx", "ly", "stemID", "treeID", "dbh", "new.band", "dendroID", "type", "dendHt")
fix <- cols[[i]]
fix
cols <- c(7,8,11,12,19,20,22,24,25,27)
col_no <- cols[[i]]
test[,col_no]
test <- rbind(data_2019, data_biannual)
test <- test[order(test$tag, test$stemtag, test$survey.ID, na.last=FALSE), ] #order by tag and survey.ID
test[,col_no] <- ifelse(is.na(test[,col_no]) & test$tag == lag(test$tag), na.locf(test[,col_no]), test[,col_no])
for (i in seq(along=cols)){
col_no <- cols[[i]]
test[,col_no] <- ifelse(is.na(test[,col_no]) & test$tag == lag(test$tag), na.locf(test[,col_no]), test[,col_no])
}
#this is done to get rid of any placeholders. Essentially, the full 2019 form was created to make the 2019 spring biannual field form. However, there were also new trees added to the survey with a survey.ID of 2019.00, so now we can get rid of these extra placeholders now that we've shifted the data above using na.locf.
test <- test[!(is.na(test$survey.ID)), ]
is.na(test$new.band)
## these values are not always constant
test$new.band <- ifelse(is.na(test$new.band), 0, test$new.band)
deadcodes <- c("DS", "DC", "DN", "DT")
test$status <- ifelse((is.na(test$status))&(test$codes %in% deadcodes), "dead", "alive")
grep(deadcodes, test$codes)
?grep
grep("D", test$codes)
gsub("RD", "RE", test$codes)
test$codes <- gsub("RD", "RE", test$codes)
grep("D", test$codes)
test$status <- ifelse(grep("D", test$codes), "dead", "alive")
test$status <- ifelse(grepl("D", test$codes), "dead", "alive")
class(test$codes)
test$codes <- as.character(test$codes)
test$codes <- ifelse(is.na(test$codes), "", test$codes)
test$notes <- as.character(test$notes)
test$notes <- ifelse(is.na(test$notes), "", test$notes)
write.csv(test, "scbi.dendroAll_2019.csv", row.names=FALSE)
View(data_biannual)
View(test)
View(data_biannual)
test$survey.ID <- ifelse(test$month == "March", 2019.01, test$survey.ID)
write.csv(test, "scbi.dendroAll_2019.csv", row.names=FALSE)
dendro_trees <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/dendro_trees.csv")
dnedro_2019 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/scbi.dendroAll_2019.csv")
View(dnedro_2019)
dendro_2019 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/scbi.dendroAll_2019.csv")
rm(dnedro_2019)
setdiff(dendro_trees$tag, dendro_2019$tag)
alive <- dendro_trees[is.na(dendro_trees$mortality.year), ]
current <- dendro_2019[dendro_2019$survey.ID == 2019.01, ]
setdiff(current$tag, alive$tag)
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/maps")
#we are using dendro_trees for this code as opposed to "scbi.dendroAll_YEAR.csv" because
#1. dendro_trees reflects the data in the all of the YEAR files and
#2. dendro_trees has the necessary mapping information in lx/ly, gx/gy, NAD83X/Y, AND lat/lon in decimal degrees.
##THUS make sure dendro_trees is updated when making new maps
dendro_trees <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/dendro_trees.csv")
#to start off, filter by all the trees that are alive as of the end of last year's fall survey.
bands_2019 <- dendro_trees[is.na(dendro_trees$mortality.year), ]
bands_2019 <- bands_2019[complete.cases(bands_2019[, c("NAD83_X", "NAD83_Y")]),] # remove one tree with missing coordinates
##this should be fixed when 131352 is found with 2018 data!!!!
library(ggplot2)
library(rgdal)
library(broom) #for the tidy function
library(sf) #for mapping
library(ggthemes) #for removing graticules when making pdf
scbi_plot <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/20m_grid.shp")
deer <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/deer_exclosure_2011.shp")
roads <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/SCBI_roads_edits.shp")
streams <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/SCBI_streams_edits.shp")
contour_10m <- readOGR("V:/SIGEO/GIS_data/dendroband surveys/dendroband intraannual/contour10m_SIGEO_clipped.shp")
survey_areas <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/maps/shapefiles/biannual_survey_areas.shp")
NS_divide <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/maps/shapefiles/NS_divide1.shp")
#convert all shp to dataframe so that it can be used by ggplot
#if tidy isn't working, can also do: xxx_df <- as(xxx, "data.frame")
scbi_plot_df <- tidy(scbi_plot)
deer_df <- tidy(deer)
roads_df <- tidy(roads)
streams_df <- tidy(streams)
survey_areas_df <- tidy(survey_areas)
NS_divide_df <- tidy(NS_divide)
contour_10m_df <- tidy(contour_10m)
#x and y give the x/yposition on the plot; sprintf says to add 0 for single digits, the x/y=seq(...,length.out) says fit the label within these parameters, fitting the length of the label evenly.
##this code adds the row and column numbers based on coordinates
rows <- annotate("text", x = seq(747350, 747365, length.out = 32), y = seq(4309125, 4308505, length.out = 32), label = sprintf("%02d", 32:1) , size=5.25, color="black")
cols <- annotate("text", x = seq(747390, 747765, length.out = 20), y = seq(4308495, 4308505, length.out = 20), label = sprintf("%02d", 1:20), size=5.4, color="black")
#these are the numbers for the survey areas, following the survey_area shp border areas
section1 <- annotate("text", x= 747730, y= 4308705, label = "1", size=6, fontface=2)
section2 <- annotate("text", x= 747630, y= 4308683, label = "2", size=6, fontface=2)
section3 <- annotate("text", x= 747450, y= 4308717, label = "3", size=6, fontface=2)
section4 <- annotate("text", x= 747445, y= 4309000, label = "4", size=6, fontface=2)
section5 <- annotate("text", x= 747567, y= 4308920, label = "5", size=6, fontface=2)
section6 <- annotate("text", x= 747687, y= 4308923, label = "6", size=6, fontface=2)
section7 <- annotate("text", x= 747520, y= 4309100, label = "7", size=6, fontface=2)
section8 <- annotate("text", x= 747605, y= 4309100, label = "8", size=6, fontface=2)
section9 <- annotate("text", x= 747725, y= 4309045, label = "9", size=6, fontface=2)
#biannual survey map ####
map <- ggplot() +
geom_path(data = scbi_plot_df, aes(x = long, y = lat, group = group))+
geom_path(data=roads_df, aes(x=long, y=lat, group=group),
color="#996600", linetype=2)+
geom_path(data=streams_df, aes(x=long, y=lat, group=group), color="blue")+
geom_path(data=survey_areas_df, aes(x=long, y=lat, group=group), size=1.1)+
geom_point(data=bands_2019, aes(x=NAD83_X, y=NAD83_Y), shape=19)+
geom_text(data=bands_2019, aes(x=NAD83_X, y=NAD83_Y, label=tag),
size=3, hjust=1.25, nudge_y=-1, nudge_x=1, check_overlap=TRUE)+
labs(title="Dendrobands_Biannual_2019")+
theme(plot.title=element_text(vjust=0.1))+
coord_sf(crs = "crs = +proj=merc", xlim=c(747350,747800), ylim=c(4308500, 4309125))
intra <- subset(bands_2019, intraannual==1)
map_intra <- ggplot() +
geom_path(data = scbi_plot_df, aes(x = long, y = lat, group = group))+
geom_path(data=roads_df, aes(x=long, y=lat, group=group),
color="#996600", linetype=2)+
geom_path(data=streams_df, aes(x=long, y=lat, group=group), color="blue")+
geom_path(data=NS_divide_df, aes(x=long, y=lat, group=group), size=1.1, color="red")+
geom_path(data=contour_10m_df, aes(x=long, y=lat, group=group), linetype=3)+
geom_path(data=deer_df, aes(x=long, y=lat, group=group))+
geom_point(data=intra, aes(x=NAD83_X, y=NAD83_Y), shape=19)+
geom_text(data=intra, aes(x=NAD83_X, y=NAD83_Y, label=tag),
size=3, hjust=1.25, nudge_y=-1, nudge_x=1, check_overlap=TRUE)+
labs(title="Dendrobands_Intraannual_2019")+
coord_sf(crs = "crs = +proj=merc", xlim=c(747350,747800), ylim=c(4308500, 4309125))
#north and south labels
north <- annotate(geom="text", x=747793, y=4308810, label="N", colour="black", size=5, fontface=2)
south <- annotate(geom="text", x=747795, y=4308775, label="S", colour="black", size=5, fontface=2)
pdf("dendroband_intraannual_map.pdf", width = 8.5, height=11)
map_intra +
rows +
cols +
north + south +
theme_map()+
theme(panel.grid.major = element_line(colour = 'transparent'))
dev.off() #when printing, choose "fit to page"
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/field_forms")
dendro19 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/scbi.dendroAll_2019.csv")
#be aware of the dbh differences
##2011-2013 data: dbh is from 2008
##2014-2018 data: dbh is from 2013
##2019-     data: dbh is from 2018
#Quick: number of bands that need to be fixed
length(c(grep("RE", dendro18$codes)))
#1 Create field and data_entry forms for trees that need fixing
##Either do 1a or 1b, then move to step 2.
#1a If don't have much time, focus on fixing the bands that need to be fixed ####
##these bands were marked as "RD" already from the field survey.
data_fix <- dendro18[grep("RE", dendro18$codes), ]
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/field_forms")
dendro19 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/scbi.dendroAll_2019.csv")
#be aware of the dbh differences
##2011-2013 data: dbh is from 2008
##2014-2018 data: dbh is from 2013
##2019-     data: dbh is from 2018
#Quick: number of bands that need to be fixed
length(c(grep("RE", dendro19$codes)))
#1 Create field and data_entry forms for trees that need fixing
##Either do 1a or 1b, then move to step 2.
#1a If don't have much time, focus on fixing the bands that need to be fixed ####
##these bands were marked as "RD" already from the field survey.
data_fix <- dendro19[grep("RE", dendro18$codes), ]
data_fix <- data_fix[which(data_fix$survey.ID == 2019.01), ] #in case any fixes have been done since the fall survey
#1a If don't have much time, focus on fixing the bands that need to be fixed ####
##these bands were marked as "RD" already from the field survey.
data_fix <- dendro19[grep("RE", dendro19$codes), ]
data_fix <- data_fix[which(data_fix$survey.ID == 2019.01), ] #in case any fixes have been done since the fall survey
dendro_trees <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/dendro_trees.csv")
data_fix$location <- dendro_trees$location[match(data_fix$stemID, dendro_trees$stemID)]
data_field<-data_fix[ ,c("tag", "stemtag", "sp", "quadrat", "lx", "ly", "dbh", "measure", "codes", "location", "dendDiam", "dendroID", "type", "dendHt")]
data_field$measure = NA
data_field$codes = NA
data_field$dendDiam = NA
data_field$dendHt = NA
data_field$type = NA
data_field$dendroID = NA
data_field$field.date = NA
data_field$dbhnew = NA
library(data.table)
setnames(data_field, old=c("codes", "stemtag"), new=c("codes&notes", "stem"))
data_field[is.na(data_field)] <- " "
data_field<-data_field[,c(1:7,15,16,12,13,11,14,8:10)]
data_field$location<-gsub("South", "S", data_field$location)
data_field$location<-gsub("North", "N", data_field$location)
View(data_field)
recensus2018 <- read.csv("T:/SIGEO/2-RECENSUS 2018/DATA/CTFS_Backups/recensus2018.csv")
View(recensus2018)
data_fix$dbh <- recensus2018$DBH[match(data_fix$tag, recensus2018$Tag)]
View(data_fix)
data_field$dbh <- recensus2018$DBH[match(data_field$tag, recensus2018$Tag)]
View(data_field)
data_field[3,7] <- 26.2
View(data_field)
data_field[3,7] <- 26.6
View(data_field)
matrix <- function(data_field, table_title) {
rbind(c(table_title, rep('', ncol(data_field)-1)), # title
names(data_field), # column names
unname(sapply(data_field, as.character))) # data
}
temp <- matrix(data_field, table_title=('Dendroband Replacement                       Date:                       Surveyors:'))
library(xlsx)
write.xlsx(temp, "field_form_fix_2019.xlsx", row.names = FALSE, col.names=FALSE)
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/data_entry_forms")
data_entry<-data_fix[ ,c(1:2,9:12,3:6,23:26,22,27:28,13:15,18:19,7:8,16:17,20:21,29:32)]
cols <- c("survey.ID", "year", "month", "day", "dbh", "measure", "codes", "notes", "field.recorders", "data.enter", "dendDiam", "dendroID", "type", "dendHt")
data_entry[, cols] <- ""
data_entry$new.band <- 1
data_entry$dir <- NA
data_entry$crown.condition <- NA
data_entry$crown.illum <- NA
data_entry$location <- NULL #we don't need this column for data entry
library(data.table)
data_entry <- setnames(old=c("dbh", "dendDiam"), new=c("dbh(mm)", "dendDiam(mm)"))
View(data_entry)
data_entry <- setnames(data_entry, old=c("dbh", "dendDiam"), new=c("dbh(mm)", "dendDiam(mm)"))
View(data_entry)
View(data_fix)
data_entry<-data_fix[ ,c(1:2,9:12,3:6,23:27,22,28:29,13:15,18:19,7:8,16:17,20:21,30:31)]
View(data_entry)
cols <- c("survey.ID", "year", "month", "day", "dbh", "measure", "codes", "notes", "field.recorders", "data.enter", "dendDiam", "dendroID", "type", "dendHt")
data_entry[, cols] <- ""
data_entry$new.band <- 1
data_entry$dir <- NA
data_entry$crown.condition <- NA
data_entry$crown.illum <- NA
data_entry$location <- NULL #we don't need this column for data entry
library(data.table)
data_entry <- setnames(data_entry, old=c("dbh", "dendDiam"), new=c("dbh(mm)", "dendDiam(mm)"))
View(data_entry)
data_entry<-data_fix[ ,c(1:2,9:12,3:6,23:27,21:22,13:18,28:29,19:20,7:8,16:17,30:31)]
cols <- c("survey.ID", "year", "month", "day", "dbh", "measure", "codes", "notes", "field.recorders", "data.enter", "dendDiam", "dendroID", "type", "dendHt")
data_entry[, cols] <- ""
data_entry$new.band <- 1
data_entry$dir <- NA
data_entry$crown.condition <- NA
data_entry$crown.illum <- NA
data_entry$location <- NULL #we don't need this column for data entry
library(data.table)
data_entry <- setnames(data_entry, old=c("dbh", "dendDiam"), new=c("dbh(mm)", "dendDiam(mm)"))
data_entry<-data_fix[ ,c(1:2,9:12,3:6,23:27,21:22,13:18,28:29,19:20,7:8,30:31)]
cols <- c("survey.ID", "year", "month", "day", "dbh", "measure", "codes", "notes", "field.recorders", "data.enter", "dendDiam", "dendroID", "type", "dendHt")
data_entry[, cols] <- ""
data_entry$new.band <- 1
data_entry$dir <- NA
data_entry$crown.condition <- NA
data_entry$crown.illum <- NA
data_entry$location <- NULL #we don't need this column for data entry
library(data.table)
data_entry <- setnames(data_entry, old=c("dbh", "dendDiam"), new=c("dbh(mm)", "dendDiam(mm)"))
View(data_entry)
View(data_field)
data_entry<-data_fix[ ,c(1:2,9:12,3:6,22:25,21,27,13:18,7:8,19:20,26,28:31)]
cols <- c("survey.ID", "year", "month", "day", "dbh", "measure", "codes", "notes", "field.recorders", "data.enter", "dendDiam", "dendroID", "type", "dendHt")
data_entry[, cols] <- ""
data_entry$new.band <- 1
data_entry$dir <- NA
data_entry$crown.condition <- NA
data_entry$crown.illum <- NA
data_entry$location <- NULL #we don't need this column for data entry
library(data.table)
data_entry <- setnames(data_entry, old=c("dbh", "dendDiam"), new=c("dbh(mm)", "dendDiam(mm)"))
View(data_entry)
write.csv(data_entry, "data_entry_fix_2019.csv", row.names=FALSE)
