data_intra$area <- NULL #this column is only relevant for field
data_intra$location <- NULL #only for when merging data pre-2018
test <- rbind(data_2015, data_intra)
test <- test[order(test[,"tag"], test[,"survey.ID"]),] #order by tag and survey.ID
## these values are constant from the previous survey.ID
library(zoo)
test$biannual <- na.locf(test$biannual)
test$intraannual <- na.locf(test$intraannual)
test$lx <- na.locf(test$lx)
test$ly <- na.locf(test$ly)
#test$stemID <- na.locf(test$stemID)
#test$treeID <- na.locf(test$treeID)
test$dbh <- na.locf(test$dbh)
## these should be constant from previous survey, but obviously are updated whenever a new dendroband is installed
test$dendroID <- na.locf(test$dendroID)
test$type <- na.locf(test$type)
test$dendHt <- na.locf(test$dendHt)
## these values are not always constant
test$new.band <- ifelse(is.na(test$new.band), 0, test$new.band)
deadcodes <- c("D", "DS", "DC", "DN", "DT")
test$status <- as.character(test$status)
test$status <- ifelse((is.na(test$status))&(test$codes %in% deadcodes), "dead",
ifelse((is.na(test$status)), na.locf(test$status), test$status))
test$codes <- as.character(test$codes)
test$codes <- ifelse(is.na(test$codes), "", test$codes)
test$notes <- as.character(test$notes)
test$notes <- ifelse(is.na(test$notes), "", test$notes)
write.csv(test, "scbi.dendroAll_2015.csv", row.names=FALSE)
}
# for biannual
#####
# for last biannual survey
data_2015 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/data_entry_forms/2015/scbi.dendroAll_2015.csv")
data_biannual <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/data_entry_forms/2015/data_entry_biannual_2015-13.csv")
names2015 <- c(colnames(data_2015))
namesbi <- c(colnames(data_biannual))
## find the names that are in data_2017 but not in data_biannual
missing <- setdiff(names2015, namesbi)
## add these missed names to data_biannual in order to combine to the master
data_biannual[missing] <- NA
data_biannual$area <- NULL #this column is only relevant for field
data_biannual$location <- NULL
test <- rbind(data_2015, data_biannual)
test <- test[order(test[,1], test[,3]),] #order by tag and survey.ID
## these values are constant from the previous survey.ID
library(zoo)
test$biannual <- na.locf(test$biannual)
test$intraannual <- na.locf(test$intraannual)
test$lx <- na.locf(test$lx)
test$ly <- na.locf(test$ly)
#test$stemID <- na.locf(test$stemID)
#test$treeID <- na.locf(test$treeID)
test$dbh <- na.locf(test$dbh)
test$dendroID <- na.locf(test$dendroID)
test$type <- na.locf(test$type)
test$dendHt <- na.locf(test$dendHt)
## these values are not always constant
test$new.band <- ifelse(is.na(test$new.band), 0, test$new.band)
deadcodes <- c("D", "DS", "DC", "DN", "DT")
test$status <- as.character(test$status)
test$status <- ifelse((is.na(test$status))&(test$codes %in% deadcodes), "dead",
ifelse((is.na(test$status)), na.locf(test$status), test$status))
test$codes <- as.character(test$codes)
test$codes <- ifelse(is.na(test$codes), "", test$codes)
test$notes <- as.character(test$notes)
test$notes <- ifelse(is.na(test$notes), "", test$notes)
write.csv(test, "scbi.dendroAll_2015.csv", row.names=FALSE)
View(test)
## for fixing intraannual qualifier (do after last biannual merge)
test$intraannual <- ifelse(!(test$survey.ID %in% c("2015.01","2015.13")), "1", "0")
"1" -> test[which(test$intraannual == "1")-1, "intraannual"]
"1" -> test[which(test$intraannual == "1")+1, "intraannual"]
write.csv(test, "scbi.dendroAll_2015.csv", row.names=FALSE)
## matching dbh and stemID/treeID
dendro15 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/2015/scbi.dendroAll_2015.csv")
dendro_trees <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/dendro_trees.csv")
dendro15$treeID <- dendro_trees$treeID[match(dendro15$tag, dendro_trees$tag)]
dendro15$stemID <- dendro_trees$stemID[match(dendro15$tag, dendro_trees$tag)]
write.csv(dendro15, "scbi.dendroAll_2015.csv", row.names=FALSE)
# for intraannual
for (i in seq(along=file_list)){
filename = file_list[[i]]
data_2015 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/data_entry_forms/2015/scbi.dendroAll_2015.csv")
data_intra <- read.csv(filename)
names2015 <- c(colnames(data_2015))
namesintra <- c(colnames(data_intra))
## find the names that are in data_2018 but not in data_biannual
missing <- setdiff(names2015, namesintra)
## if need be, do the opposite
# missing <- setdiff(namesbi, names2018)
## add these missed names to data_biannual in order to combine to the master
data_intra[missing] <- NA
data_intra$area <- NULL #this column is only relevant for field
data_intra$location <- NULL #only for when merging data pre-2018
test <- rbind(data_2015, data_intra)
test <- test[order(test[,"tag"], test[,"survey.ID"]),] #order by tag and survey.ID
## these values are constant from the previous survey.ID
library(zoo)
test$biannual <- na.locf(test$biannual)
test$intraannual <- na.locf(test$intraannual)
test$lx <- na.locf(test$lx)
test$ly <- na.locf(test$ly)
#test$stemID <- na.locf(test$stemID)
#test$treeID <- na.locf(test$treeID)
test$dbh <- na.locf(test$dbh)
## these should be constant from previous survey, but obviously are updated whenever a new dendroband is installed
test$dendroID <- na.locf(test$dendroID)
test$type <- na.locf(test$type)
test$dendHt <- na.locf(test$dendHt)
## these values are not always constant
test$new.band <- ifelse(is.na(test$new.band), 0, test$new.band)
deadcodes <- c("D", "DS", "DC", "DN", "DT")
test$status <- as.character(test$status)
test$status <- ifelse((is.na(test$status))&(test$codes %in% deadcodes), "dead",
ifelse((is.na(test$status)), na.locf(test$status), test$status))
test$codes <- as.character(test$codes)
test$codes <- ifelse(is.na(test$codes), "", test$codes)
test$notes <- as.character(test$notes)
test$notes <- ifelse(is.na(test$notes), "", test$notes)
write.csv(test, "scbi.dendroAll_2015.csv", row.names=FALSE)
}
# for intraannual
for (i in seq(along=file_list)){
filename = file_list[[i]]
data_2015 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/data_entry_forms/2015/scbi.dendroAll_2015.csv")
data_intra <- read.csv(filename)
names2015 <- c(colnames(data_2015))
namesintra <- c(colnames(data_intra))
## find the names that are in data_2018 but not in data_biannual
missing <- setdiff(names2015, namesintra)
## if need be, do the opposite
# missing <- setdiff(namesbi, names2018)
## add these missed names to data_biannual in order to combine to the master
data_intra[missing] <- NA
data_intra$area <- NULL #this column is only relevant for field
data_intra$location <- NULL #only for when merging data pre-2018
test <- rbind(data_2015, data_intra)
test <- test[order(test[,"tag"], test[,"survey.ID"]),] #order by tag and survey.ID
## these values are constant from the previous survey.ID
library(zoo)
test$biannual <- na.locf(test$biannual)
test$intraannual <- na.locf(test$intraannual)
test$lx <- na.locf(test$lx)
test$ly <- na.locf(test$ly)
test$stemID <- na.locf(test$stemID)
test$treeID <- na.locf(test$treeID)
test$dbh <- na.locf(test$dbh)
## these should be constant from previous survey, but obviously are updated whenever a new dendroband is installed
test$dendroID <- na.locf(test$dendroID)
test$type <- na.locf(test$type)
test$dendHt <- na.locf(test$dendHt)
## these values are not always constant
test$new.band <- ifelse(is.na(test$new.band), 0, test$new.band)
deadcodes <- c("D", "DS", "DC", "DN", "DT")
test$status <- as.character(test$status)
test$status <- ifelse((is.na(test$status))&(test$codes %in% deadcodes), "dead",
ifelse((is.na(test$status)), na.locf(test$status), test$status))
test$codes <- as.character(test$codes)
test$codes <- ifelse(is.na(test$codes), "", test$codes)
test$notes <- as.character(test$notes)
test$notes <- ifelse(is.na(test$notes), "", test$notes)
write.csv(test, "scbi.dendroAll_2015.csv", row.names=FALSE)
}
data_2015 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/data_entry_forms/2015/scbi.dendroAll_2015.csv")
data_biannual <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/data_entry_forms/2015/data_entry_biannual_2015-13.csv")
names2015 <- c(colnames(data_2015))
namesbi <- c(colnames(data_biannual))
## find the names that are in data_2017 but not in data_biannual
missing <- setdiff(names2015, namesbi)
## if need be, do the opposite
# missing <- setdiff(namesbi, names2017)
## add these missed names to data_biannual in order to combine to the master
data_biannual[missing] <- NA
data_biannual$area <- NULL #this column is only relevant for field
data_biannual$location <- NULL
test <- rbind(data_2015, data_biannual)
test <- test[order(test[,1], test[,3]),] #order by tag and survey.ID
## these values are constant from the previous survey.ID
library(zoo)
test$biannual <- na.locf(test$biannual)
test$intraannual <- na.locf(test$intraannual)
test$lx <- na.locf(test$lx)
test$ly <- na.locf(test$ly)
test$stemID <- na.locf(test$stemID)
test$treeID <- na.locf(test$treeID)
test$dbh <- na.locf(test$dbh)
## these should be constant from previous survey, but obviously are updated whenever a new dendroband is installed
test$dendroID <- na.locf(test$dendroID)
test$type <- na.locf(test$type)
test$dendHt <- na.locf(test$dendHt)
## these values are not always constant
test$new.band <- ifelse(is.na(test$new.band), 0, test$new.band)
deadcodes <- c("D", "DS", "DC", "DN", "DT")
test$status <- as.character(test$status)
test$status <- ifelse((is.na(test$status))&(test$codes %in% deadcodes), "dead",
ifelse((is.na(test$status)), na.locf(test$status), test$status))
test$codes <- as.character(test$codes)
test$codes <- ifelse(is.na(test$codes), "", test$codes)
test$notes <- as.character(test$notes)
test$notes <- ifelse(is.na(test$notes), "", test$notes)
## for fixing intraannual qualifier (do after last biannual merge)
test$intraannual <- ifelse(!(test$survey.ID %in% c("2015.01","2015.13")), "1", "0")
"1" -> test[which(test$intraannual == "1")-1, "intraannual"]
"1" -> test[which(test$intraannual == "1")+1, "intraannual"]
write.csv(test, "scbi.dendroAll_2015.csv", row.names=FALSE)
dendro15 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/2015/scbi.dendroAll_2015.csv")
dendro_trees <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/dendro_trees.csv")
dendro15$treeID <- dendro_trees$treeID[match(dendro15$tag, dendro_trees$tag)]
dendro15$stemID <- dendro_trees$stemID[match(dendro15$tag, dendro_trees$tag)]
write.csv(dendro15, "scbi.dendroAll_2015.csv", row.names=FALSE)
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/data_entry_forms/2015")
file_list <- list.files("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/data_entry_forms/2015", pattern="data_entry_intraannual")
# for intraannual
for (i in seq(along=file_list)){
filename = file_list[[i]]
data_2015 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/data_entry_forms/2015/scbi.dendroAll_2015.csv")
data_intra <- read.csv(filename)
names2015 <- c(colnames(data_2015))
namesintra <- c(colnames(data_intra))
## find the names that are in data_2018 but not in data_biannual
missing <- setdiff(names2015, namesintra)
## if need be, do the opposite
# missing <- setdiff(namesbi, names2018)
## add these missed names to data_biannual in order to combine to the master
data_intra[missing] <- NA
data_intra$area <- NULL #this column is only relevant for field
data_intra$location <- NULL #only for when merging data pre-2018
test <- rbind(data_2015, data_intra)
test <- test[order(test[,"tag"], test[,"survey.ID"]),] #order by tag and survey.ID
## these values are constant from the previous survey.ID
library(zoo)
test$biannual <- na.locf(test$biannual)
test$intraannual <- na.locf(test$intraannual)
test$lx <- na.locf(test$lx)
test$ly <- na.locf(test$ly)
test$stemID <- na.locf(test$stemID)
test$treeID <- na.locf(test$treeID)
test$dbh <- na.locf(test$dbh)
## these should be constant from previous survey, but obviously are updated whenever a new dendroband is installed
test$dendroID <- na.locf(test$dendroID)
test$type <- na.locf(test$type)
test$dendHt <- na.locf(test$dendHt)
## these values are not always constant
test$new.band <- ifelse(is.na(test$new.band), 0, test$new.band)
deadcodes <- c("D", "DS", "DC", "DN", "DT")
test$status <- as.character(test$status)
test$status <- ifelse((is.na(test$status))&(test$codes %in% deadcodes), "dead",
ifelse((is.na(test$status)), na.locf(test$status), test$status))
test$codes <- as.character(test$codes)
test$codes <- ifelse(is.na(test$codes), "", test$codes)
test$notes <- as.character(test$notes)
test$notes <- ifelse(is.na(test$notes), "", test$notes)
write.csv(test, "scbi.dendroAll_2015.csv", row.names=FALSE)
}
# for biannual
#####
# for last biannual survey
data_2015 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/data_entry_forms/2015/scbi.dendroAll_2015.csv")
data_biannual <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/data_entry_forms/2015/data_entry_biannual_2015-13.csv")
names2015 <- c(colnames(data_2015))
namesbi <- c(colnames(data_biannual))
## find the names that are in data_2017 but not in data_biannual
missing <- setdiff(names2015, namesbi)
## if need be, do the opposite
# missing <- setdiff(namesbi, names2017)
## add these missed names to data_biannual in order to combine to the master
data_biannual[missing] <- NA
data_biannual$area <- NULL #this column is only relevant for field
data_biannual$location <- NULL
test <- rbind(data_2015, data_biannual)
test <- test[order(test[,1], test[,3]),] #order by tag and survey.ID
## these values are constant from the previous survey.ID
library(zoo)
test$biannual <- na.locf(test$biannual)
test$intraannual <- na.locf(test$intraannual)
test$lx <- na.locf(test$lx)
test$ly <- na.locf(test$ly)
test$stemID <- na.locf(test$stemID)
test$treeID <- na.locf(test$treeID)
test$dbh <- na.locf(test$dbh)
## these should be constant from previous survey, but obviously are updated whenever a new dendroband is installed
test$dendroID <- na.locf(test$dendroID)
test$type <- na.locf(test$type)
test$dendHt <- na.locf(test$dendHt)
## these values are not always constant
test$new.band <- ifelse(is.na(test$new.band), 0, test$new.band)
deadcodes <- c("D", "DS", "DC", "DN", "DT")
test$status <- as.character(test$status)
test$status <- ifelse((is.na(test$status))&(test$codes %in% deadcodes), "dead",
ifelse((is.na(test$status)), na.locf(test$status), test$status))
test$codes <- as.character(test$codes)
test$codes <- ifelse(is.na(test$codes), "", test$codes)
test$notes <- as.character(test$notes)
test$notes <- ifelse(is.na(test$notes), "", test$notes)
## for fixing intraannual qualifier (do after last biannual merge)
test$intraannual <- ifelse(!(test$survey.ID %in% c("2015.01","2015.13")), "1", "0")
"1" -> test[which(test$intraannual == "1")-1, "intraannual"]
"1" -> test[which(test$intraannual == "1")+1, "intraannual"]
write.csv(test, "scbi.dendroAll_2015.csv", row.names=FALSE)
recensus2018 <- read.csv("I:/recensus2018.csv")
dendro_cored <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_dimensions/tree_crowns/dendro_cored_full.csv")
library(data.table)
recensus2018 <- setnames(recensus2018, old=c("Tag", "StemTag"), new=c("tag", "stemtag"))
combo <- merge(dendro_cored, recensus2018, by=c("tag", "stemtag"))
combo <- combo[order(combo[,1]),]
combo <- setnames(combo, old=c("DBH"), new=c("dbh2018"))
combo$dbh2018 <- combo$dbh2018*10
namescombo <- c(combo$tag)
namescored <- c(dendro_cored$tag)
## find the names that are in data_2017 but not in data_biannual
missing <- setdiff(namescored, namescombo)
missing1 <- setdiff(namescombo, namescored)
namescombo[!(namescombo %in% namescored)]
combo$QuadratName <- NULL
combo$Mnemonic <- NULL
combo$OldDBH <- NULL
combo$OldCodes <- NULL
combo$Comments <- NULL
combo$Errors <- NULL
combo$ExactDate <- NULL
combo$X <- NULL
combo$Y <- NULL
combo$dataset <- NULL
deadcodes <- c("D", "DS", "DC", "DN", "DT")
combo$status <- as.character(combo$status)
combo$status <- ifelse(deadcodes %in% combo$codes, "dead", combo$status)
combodead <- grep("^D", combo$Codes)
View(combo)
combo$status <- ifelse(combo$Codes %in% combodead, "dead", combo$status)
combo$Codes <- NULL
combo <- combo[,c(1:8,26,9:25)]
write.csv(combo, "dendro_cored_full.csv", row.names=FALSE)
getwd()
combodead <- grepl("^D", combo$Codes)
View(combo)
combo <- combo[!duplicated(combo$stemID),]
View(combo)
combodead <- grepl("^D", combo$Codes)
combo <- merge(dendro_cored, recensus2018, by=c("tag", "stemtag"))
combo <- combo[order(combo[,1]),]
combo <- setnames(combo, old=c("DBH"), new=c("dbh2018"))
combo$dbh2018 <- combo$dbh2018*10
namescombo <- c(combo$tag)
namescored <- c(dendro_cored$tag)
## find the names that are in data_2017 but not in data_biannual
missing <- setdiff(namescored, namescombo)
missing1 <- setdiff(namescombo, namescored)
namescombo[!(namescombo %in% namescored)]
combo$QuadratName <- NULL
combo$Mnemonic <- NULL
combo$OldDBH <- NULL
combo$OldCodes <- NULL
combo$Comments <- NULL
combo$Errors <- NULL
combo$ExactDate <- NULL
combo$X <- NULL
combo$Y <- NULL
combo$dataset <- NULL
deadcodes <- c("D", "DS", "DC", "DN", "DT")
combo$status <- as.character(combo$status)
combodead <- grepl("^D", combo$Codes)
combo$status <- ifelse(combo$Codes %in% combodead, "dead", combo$status)
combodead <- grepl("^D", combo$Codes)
combodead
combodead <- ifelse(grepl("^D", combo$Codes), combo$Codes, "")
combodead <- print(grepl("^D", combo$Codes))
combodead <- combo[combo$Codes == "^D"]
combo$status <- ifelse(combo$Codes %in% combodead, "dead", combo$status)
View(combo)
combodead <- combo[combo$Codes == "^D+[:punct:]"]
combodead <- combo[combo$Codes == "^D[:punct:]"]
combodead <- combo[combo$Codes == "^D.[:punct:]"]
combodead <- combo[combo$Codes == "^D.[:punct:]+$"]
combodead <- combo[combo$Codes == "^D.[:punct:]+."]
combodead <- combo[combo$Codes == "^D.[:punct:]."]
combodead <- combo[combo$Codes == "^D.[:punct:].$"]
combodead <- combo[combo$Codes == "^D.[:punct:].$", "Codes"]
combodead
combodead <- combo[combo$Codes == "^D", "Codes"]
combodead <- combo[combo$Codes == "^D.[:punct:].$"]
combodead <- combo[combo$Codes == "^D.[:punct:].$", "Codes"]
combodead <- combo[combo$Codes == "^D", "Codes"]
combodead <- subset(combo$Codes, Combo$Codes == "^D")
combodead <- subset(combo$Codes, combo$Codes == "^D")
combodead == D
combodead == "^D"
combodead <- combo[combo$Codes, "Codes"]
deadcodes <- subset(combodead, "^D")
deadcodes <- subset(combodead, D)
?subset
deadcodes <- subset(combodead, "A")
combodead
View(combo)
combodead <- combo[combo$Codes == "^D", "Codes"]
.$
combodead <- combo[combo$Codes == "^D.[:punct:].$", "Codes"]
combodead <- combo[combo$Codes == "^D.[:punct:].$"]
combodead <- combo[combo$Codes == "^D.[:punct:].$", "Codes"]
combodead <- print(grepl("^D", combo$Codes))
combodead <- grepl("^D", combo$Codes)
combodead <- grep("^D", combo$Codes)
combodead
Combo$status <- gsub("^D", "D", combo)
combo$status <- gsub("^D", "D", combo)
combo$status <- ifelse(combo$Codes %in% deadcodes, "dead", combo$status)
combo$Codes <- NULL
combo <- combo[,c(1:8,26,9:25)]
combo <- combo[!duplicated(combo$stemID),]
write.csv(combo, "dendro_cored_full.csv", row.names=FALSE)
combo <- merge(dendro_cored, recensus2018, by=c("tag", "stemtag"))
combo <- combo[order(combo[,1]),]
combo <- setnames(combo, old=c("DBH"), new=c("dbh2018"))
combo$dbh2018 <- combo$dbh2018*10
namescombo <- c(combo$tag)
namescored <- c(dendro_cored$tag)
## find the names that are in data_2017 but not in data_biannual
missing <- setdiff(namescored, namescombo)
missing1 <- setdiff(namescombo, namescored)
namescombo[!(namescombo %in% namescored)]
combo$QuadratName <- NULL
combo$Mnemonic <- NULL
combo$OldDBH <- NULL
combo$OldCodes <- NULL
combo$Comments <- NULL
combo$Errors <- NULL
combo$ExactDate <- NULL
combo$X <- NULL
combo$Y <- NULL
combo$dataset <- NULL
deadcodes <- c("D", "DS", "DC", "DN", "DT")
combo$status <- as.character(combo$status)
View(combo)
combo$status <- gsub("^D", "D", combo)
combo <- merge(dendro_cored, recensus2018, by=c("tag", "stemtag"))
combo <- combo[order(combo[,1]),]
combo <- setnames(combo, old=c("DBH"), new=c("dbh2018"))
combo$dbh2018 <- combo$dbh2018*10
namescombo <- c(combo$tag)
namescored <- c(dendro_cored$tag)
## find the names that are in data_2017 but not in data_biannual
missing <- setdiff(namescored, namescombo)
missing1 <- setdiff(namescombo, namescored)
namescombo[!(namescombo %in% namescored)]
combo$QuadratName <- NULL
combo$Mnemonic <- NULL
combo$OldDBH <- NULL
combo$OldCodes <- NULL
combo$Comments <- NULL
combo$Errors <- NULL
combo$ExactDate <- NULL
combo$X <- NULL
combo$Y <- NULL
combo$dataset <- NULL
deadcodes <- c("D", "DS", "DC", "DN", "DT")
combo$status <- as.character(combo$status)
combo$Codes <- gsub("^D", "D", combo$Codes)
View(combo)
combo$Codes <- gsub("^D", "D", combo)
View(combo)
combodead <- combo[substr(combo$Codes) == "^D"]
combodead <- combo[substr(combo$Codes, A, X) == "^D"]
combodead <- combo[substr(combo$Codes, "A", "X") == "^D"]
combodead <- grep("^D", combo$Codes)
combo <- merge(dendro_cored, recensus2018, by=c("tag", "stemtag"))
combo <- combo[order(combo[,1]),]
combo <- setnames(combo, old=c("DBH"), new=c("dbh2018"))
combo$dbh2018 <- combo$dbh2018*10
namescombo <- c(combo$tag)
namescored <- c(dendro_cored$tag)
## find the names that are in data_2017 but not in data_biannual
missing <- setdiff(namescored, namescombo)
missing1 <- setdiff(namescombo, namescored)
namescombo[!(namescombo %in% namescored)]
combo$QuadratName <- NULL
combo$Mnemonic <- NULL
combo$OldDBH <- NULL
combo$OldCodes <- NULL
combo$Comments <- NULL
combo$Errors <- NULL
combo$ExactDate <- NULL
combo$X <- NULL
combo$Y <- NULL
combo$dataset <- NULL
deadcodes <- c("D", "DS", "DC", "DN", "DT")
combo$status <- as.character(combo$status)
combo$Codes <- gsub("^D", "D", combo$Codes)
combodead <- grep("^D", combo$Codes)
View(combo)
combodead <- grep("^D", combo$Codes)
combodead\
combodead
combodead <- grep("^D", combo$Codes, paste0())
combodead <- paste(grep("^D", combo$Codes))
combodead <- paste0(grep("^D", combo$Codes))
deadcodes <- c("^D")
combo$status <- ifelse(combo$Codes %in% deadcodes, "dead", combo$status)
View(combo)
combodead <- combo[which(combo$Codes == "^D"),]
combodead <- c(combo[which(combo$Codes == "^D"),])
View(combodead)
combodead <- grep("^D", combo$Codes)
combodead <- grep("^D", combo$Codes, value = TRUE)
?grep
deadcodes <- grep("^D", combo$Codes, value = TRUE)
deadcodes
combo$status <- ifelse(combo$Codes %in% deadcodes, "dead", combo$status)
View(combo)
combo$Codes <- NULL
combo <- combo[,c(1:8,26,9:25)]
combo <- combo[!duplicated(combo$stemID),]
write.csv(combo, "dendro_cored_full.csv", row.names=FALSE)
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/data_entry_forms/2016")
