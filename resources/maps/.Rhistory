View(tree_sp_new)
tree_sp_new <- merge(tree_sp, Merged_dendroband_utm_lat_lon, by=c("tag", "StemTag", all=FALSE))
tree_sp_new <- merge(tree_sp, Merged_dendroband_utm_lat_lon, by=c("tag", "StemTag"), all=FALSE)
View(tree_sp_new)
View(tree_sp)
View(tree_sp_new1)
View(tree_sp_new)
View(Merged_dendroband_utm_lat_lon)
?grepl
grepl(10011, tree_sp$tag)
tree_sp_new <- merge(tree_sp, Merged_dendroband_utm_lat_lon, by=c("tag", "StemTag", "treeID"), all=FALSE)
View(tree_sp_new)
install.packages("compare")
library(compare)
compare(tree_sp, tree_sp_new,allowAll = TRUE)
comparison<-compare(tree_sp, tree_sp_new,allowAll = TRUE)
View(comparison)
comparison$tag
library(dplyr)
anti_join(tree_sp$tag, tree_sp_new$tag)
anti_join(tree_sp, tree_sp_new)
View(tree_sp)
colnames(tree_sp)
tree_sp$tag
tree_sp_new$tag
getwd(\)
getwd()
write.csv(tree_sp_new, "testthing.csv")
?unique
unique(tree_sp_new)
tree_sp_new1<-unique(tree_sp_new)
View(tree_sp_new1)
tree_sp_new1<-tree_sp_new %>% distinct(tag, .keep_all=TRUE)
View(tree_sp_new1)
tree_sp_new1<-tree_sp_new %>% distinct(tag, StemTag, .keep_all=TRUE)
tree_sp_new1<-tree_sp_new %>% distinct(tag, StemTag, stemID, .keep_all=TRUE)
View(tree_sp_new1)
ifelse(tree_sp$tag==tree_sp_new1, TRUE, FALSE)
ifelse(tree_sp$tag==tree_sp_new1$tag, TRUE, FALSE)
ifelse(tree_sp$tag==tree_sp_new1$tag, TRUE, FALSE)
View(tree_sp_new1)
tree_sp<-c(tree_sp$tag)
tree_sp_new1<-c(tree_sp_new1$tag)
original<-c(tree_sp$tag)
tree_sp <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/metadata/tree_sp.csv")
View(tree_sp)
original<-c(tree_sp$tag)
original[original %in% tree_sp_new1]
original[!(original %in% tree_sp_new1)]
tree_sp_new1<-tree_sp_new %>% distinct(tag, StemTag, stemID, .keep_all=TRUE)
new1<-c(tree_sp_new1$tag)
original[original %in% new1]
original[!(original %in% new1)]
write.csv(tree_sp_new1, "tree_sp.csv")
#adapted from http://spatialanalysis.co.uk/wp-content/uploads/2012/07/exporting-to-kml.txt
library(sp)
library(maptools)
library(rgdal)
library(mapview)
setwd()
ForC_sites <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/ForC/data/ForC_sites.csv")
coordinates(ForC_sites)<- c("lon", "lat")
BNG<- CRS("+init=epsg:4326") #reference from http://spatialreference.org/ref/epsg/4326/
p4s <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84")
proj4string(ForC_sites)<-BNG
ForC_wgs84<- spTransform(ForC_sites, CRS=p4s)
mapview(ForC_wgs84, label=ForC_sites$sites.sitename)
#we can use the basic open Esri.WorldImagery behind this and it works. Other maps can be obtained below.
#with mapview it is easy to change symbology, add legends, etc. This can be an option for the future.
library(ggmap)
get_map(source="google", maptype="hybrid")
#for whatever reason it won't let me download the map because it is "403 Forbidden." I have no idea if this is an IT issue or not.
scbi.dendroAll_2018 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/clean_data_files/2018/scbi.dendroAll_2018.csv")
View(scbi.dendroAll_2018)
dendroID_chronology <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/clean_data_files/dendroID_chronology.csv", stringsAsFactors=FALSE)
View(dendroID_chronology)
data_stem<-scbi.dendroAll_2018[which(scbi.dendroAll_2018$survey.ID=='2018.01'), ] #subset by 2018.01 (one entry per stem)
scbi.dendroAll_2018$dendroID <- dendroID_chronology$X2018.dendroID[match(scbi.dendroAll_2018$tag, dendroID_chronology$tag)]
View(scbi.dendroAll_2018)
write.csv(scbi.dendroAll_2018, "scbi.dendroAll_2018.csv")
getwd()
dendro_cored_full <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/clean_data_files/dendro_cored_full.csv")
View(dendro_cored_full)
cores <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/climate_sensitivity_cores/data/census_data_for_cored_trees.csv")
dendro_trees <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/clean_data_files/dendro_trees.csv")
library(data.table)
setnames(cores, old=c("StemTag"), new=c("stemtag"))
dendro_trees$year.cored <-cores$year.cored[match(dendro_trees$tag,cores$tag)]
dendro_merge <- merge(dendro_trees, cores, by=c("tag", "stemtag", "sp", "quadrat", "treeID", "stemID", "status", "gx", "gy","year.cored"), all.x=TRUE, all.y=TRUE)
dendro_all <- dendro_merge[c(1:19)]
##order the data and remove the crossovers (btwn biannual and cored) that don't have biannual marked already
dendro_all <- dendro_all[order(dendro_all$tag,dendro_all$biannual),]
dendro_all$stemID[is.na(dendro_all$stemID)] <- 0
##WARNING:assign stemID values for 30365 and 131352 (discrepancy with 2013 census). THIS PART SHOULD BE DELETED once the 2018 census data includes these tags with the appropriate info.
dendro_all[91,6]=11
dendro_all[867,6]=12
dendro_all<-dendro_all[!duplicated(dendro_all$stemID),]
##populate with geographic coordinates
latlon <- read.csv("V:/SIGEO/GIS_data/dendroband surveys/Merged_dendroband_utm_lat_lon.csv")
dendro_all$NAD83_X <- latlon$NAD83_X[match(dendro_all$stemID, latlon$stemID)]
dendro_all$NAD83_Y <- latlon$NAD83_Y[match(dendro_all$stemID, latlon$stemID)]
dendro_all$lat <- latlon$lat[match(dendro_all$stemID, latlon$stemID)]
dendro_all$lon <- latlon$lon[match(dendro_all$stemID, latlon$stemID)]
##populate with lx, ly, and status (once ForestGEO 2018 census data is added, use that for base status)
census_2013 <- read.csv("V:/SIGEO/3-RECENSUS 2013/DATA/FINAL DATA to use, to share/scbi.stem2.csv")
dendro_all$lx <- $lx[match(dendro_all$stemID, $stemID)]
dendro_all$ly <- $ly[match(dendro_all$stemID, $stemID)]
##update status from most recent mortality data (this will update only some of the trees, hence why the census data is used first)
mortality_2018 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data_private/SCBI_mortality/raw data/Mortality_Survey_2018.csv")
dendro_all$status <- mortality_2018$new.status[match(dendro_all$tag, mortality_2018$tag)]
missing <- ifelse(is.na(dendro_all$status), dendro_all$tag, "")
missingdf <- dendro_all[!complete.cases(dendro_all$status),]
missingdf <- missingdf[c(1:2)]
setnames(census_2013, old=c("StemTag"), new=c("stemtag"))
dendro_test <- merge(missingdf, census_2013[,c("tag", "stemtag","status")], by=c("tag","stemtag"))
dendro_all <- merge(dendro_all, dendro_test, by="tag", all.x=TRUE)
setnames(dendro_all, old="stemtag.x", new="stemtag")
library(tidyr)
dendro_all <- unite(dendro_all, status, status.x, status.y)
dendro_all$status <- gsub("_NA", "", dendro_all$status)
dendro_all$status <- gsub("NA_", "", dendro_all$status)
dendro_all$status <- gsub("PD", "D", dendro_all$status)
dendro_all$status <- gsub("DS", "D", dendro_all$status)
dendro_all$status <- gsub("DC", "D", dendro_all$status)
dendro_all$status <- gsub("AU", "A", dendro_all$status)
##get rid of NA
dendro_all$biannual[is.na(dendro_all$biannual)] <- 0
dendro_all$intraannual[is.na(dendro_all$intraannual)] <- 0
dendro_all$cored[is.na(dendro_all$cored)] <- 1
##re-order
dendro_all <- dendro_all[c(1:6,11:13,10,7,14:15,8:9,16:19)]
#get rid of final duplicates now that all rows are the same
dendro_all <- dendro_all[!duplicated(dendro_all),]
write.csv(dendro_all, "dendro_cored_full.csv", row.names=FALSE)
getwd()
dendro_cored_full <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/clean_data_files/dendro_cored_full.csv")
View(dendro_cored_full)
library(dplyr)
dendro <- dendro_cored_full %>%
filter(status==A)
dendro <- dendro_cored_full %>%
filter(status=="A")
View(dendro)
dendro <- dendro[c(1:4,7:11)]
View(dendro)
dendro <- dendro[c(1:4,7:10)]
dendro <- dendro_cored_full %>%
filter(status=="A")
dendro <- dendro[c(1:4,7:10)]
View(dendro)
dendro$crown.position <- ""
View(dendro)
write.csv(dendro, "scbi.crownposition.csv")
getwd()
install.packages(devtools)
install.packages("devtools")
devtools::install_github("forestgeo/fgeo")
library(fgeo)
devtools::install_github("forestgeo/fgeo")
library(fgeo)
fgeo(help)
install.packages(c("animation", "aqp", "backports", "BH", "bookdown", "broom", "callr", "carData", "checkmate", "classInt", "clipr", "colorspace", "curl", "data.table", "dbplyr", "dplR", "dplyr", "e1071", "esquisse", "expss", "flextable", "FNN", "ggmap", "ggvis", "git2r", "googleVis", "haven", "Hmisc", "htmlTable", "htmlwidgets", "httpuv", "httr", "jsonlite", "lemon", "lme4", "mapview", "markdown", "measurements", "mgcv", "nloptr", "openssl", "packrat", "pillar", "plotKML", "processx", "ps", "psych", "purrr", "quantreg", "raster", "rcmdcheck", "Rcpp", "RcppEigen", "readr", "readxl", "reshape", "rio", "RJSONIO", "rlang", "rmarkdown", "rsconnect", "rstudioapi", "sessioninfo", "sf", "shiny", "shinyWidgets", "spam", "spData", "stars", "testthat", "tibble", "tidybayes", "tinytex", "tmap", "units", "waveslim", "webshot", "writexl", "xts"))
install.packages("pupR")
dendro2011 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/scbi.dendroAll_2011.csv")
dendro2012 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/scbi.dendroAll_2012.csv")
View(dendro2011)
View(dendro2012)
dendro2012 <- dendro2012[dendro2012$new.band==1, ]
farms <- data.frame(lat=runif(3), lng=runif(3))
dist(farms, diag=T, upper=T)
#behold the vegan package
farms <- data.frame(lat=runif(20), lng=runif(20))
View(farms)
rownames(farms) <- "A:Z"
rownames(farms) <- "[[:alpha:]]"
"[[:alpha:]]"
[[:alpha:]]
[:alpha:]
rownames(farms) <- 180001:180026
rownames(farms) <- 180001:180027
#behold the vegan package
farms <- data.frame(lat=runif(26), lng=runif(26))
rownames(farms) <- 180001:180026
View(farms)
d <- vegdist(farms, method="euclidean") #caluclate distance
#behold the vegan package
library(vegan)
d <- vegdist(farms, method="euclidean") #caluclate distance
m <- data.frame(t(combn(rownames(farms),2)), as.numeric(d)) #put in df format
names(m) <- c("tree1", "tree2", "distance")
View(m)
scbi.full2 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_main_census/data/census-csv-files/scbi.full2.csv", stringsAsFactors=FALSE)
scbi.full2[5340, 3] <- 40874 #duplicated tag
trees <- scbi.full2[scbi.full2$dbh>=100  & !grepl("S", scbi.full2$codes), ]
trees <- trees[c(3,7,8)]
rownames(trees) <- trees[,1]
trees <- trees[, -1]
library(vegan)
d <- vegdist(trees, method="euclidean") #calculate distance between one tree and all the other trees using Pythagorean theorem
m <- data.frame(t(combn(rownames(trees),2)), as.numeric(d)) #put in df format
names(m) <- c("tree1", "tree2", "distance")
simple <- m[m$distance<=30, ] #only include distances of 30m or less
simple <- simple[sort(simple$tree1, simple$distance)]
?sort
?order
simple <- simple[order(simple$tree1, simple$distance)]
simple <- simple[order(simple$tree1, simple$distance), ]
View(simple)
scbi.2013 <- scbi.full2[scbi.full2$tag %in% unique(simple$tree1), ]
setdiff(unique(simple$tree1), scbi.2013$tag)
unique(simple$tree1)
q <- unique(simple$tree1)
p <- scbi.2013[duplicated(scbi.2013$tag)]
p <- scbi.2013[duplicated(scbi.2013$tag), ]
View(p)
scbi.sub <- scbi.full2[scbi.full2$dbh>=100  & !grepl("S", scbi.full2$codes), ]
trees <- scbi.sub[c(3,7,8)]
rownames(trees) <- trees[,1]
trees <- trees[, -1]
scbi.sub <- scbi.sub[scbi.sub$tag %in% unique(simple$tree1), ]
p <- trees[duplicated(rownames(trees)), ]
setdiff(unique(simple$tree1), scbi.sub$tag)
View(trees)
rm(scbi.2013)
scbi.full2 <- scbi.full2[scbi.full2$dbh>=100  & !grepl("S", scbi.full2$codes), ]
trees <- scbi.full2[c(3,7,8)]
rownames(trees) <- trees[,1]
trees <- trees[, -1]
scbi.sub <- scbi.full2[scbi.full2$tag %in% unique(simple$tree1), ] #this number won't match "trees" because some trees from scbi.sub are >30m apart from another tree
View(simple)
View(scbi.sub)
scbi.sub <- scbi.sub[c(3,7,8,11)]
scbi.sub$basal <- pi*(scbi.sub$dbh/2)^2
View(scbi.sub)
scbi.sub$dbh <- scbi.sub$dbh/10
View(scbi.sub)
scbi.sub$basal <- pi*(scbi.sub$dbh/2)^2
View(scbi.sub)
?seq
seq(1,30, by=0.5)
seq(0,30, by=0.5)
dist <- seq(0,30, by=0.5)
scbi.sub[, dist] <- NA
scbi.sub[dist] <- NA
?rep
gsub("^", "X", dist)
gsub("^", "x", dist)
dist <- gsub("^", "x", dist)
scbi.sub[, dist] <- NA
View(scbi.sub)
scbi.sub$basal <- (pi*(scbi.sub$dbh/2)^2)*0.0001
View(scbi.sub)
View(m)
View(simple)
test <- simple[simple$tree1 == 12165, ]
View(test)
test <- simple[simple$tree1 == 12165 | simple$tree2 == 12165, ]
View(test)
sum(test$distance)
sum(test$distance) / 30
scbi.sub[scbi.sub$tag==12171, ]
scbi.sub[scbi.sub$tag==12173, ]
colnames(scbi.sub[, 6:ncol(scbi.sub)])
i=1
inc <- colnames(scbi.sub[, 6:ncol(scbi.sub)])[[i]]
inc <- gsub("x", "", inc)
inc <- colnames(scbi.sub[, 6:ncol(scbi.sub)])[[i]]
inc_num <- gsub("x", "", inc)
j=1
test <- simple[simple$tree1 | simple$tree2 == simple$tree1[[j]], ]
simple$tree1 <- as.numeric(simple$tree1)
simple$tree2 <- as.numeric(simple$tree2)
test <- simple[simple$tree1 | simple$tree2 == simple$tree1[[j]], ]
test <- simple[simple$tree1 == simple$tree[[j]] | simple$tree2 == simple$tree1[[j]], ]
simple$tree1
simple <- m[m$distance<=30, ] #only include distances of 30m or less
simple <- simple[order(simple$tree1, simple$distance), ] #sort by tree and distance
simple$tree1 <- as.character(simple$tree1)
View(simple)
simple$tree2 <- as.character(simple$tree2)
View(simple)
simple$tree2 <- as.numeric(simple$tree2)
simple$tree1 <- as.numeric(simple$tree1)
View(simple)
test <- simple[simple$tree1 == simple$tree[[j]] | simple$tree2 == simple$tree1[[j]], ]
simple$tree1
tree <- unique(simple$tree1)[[j]]
test <- simple[simple$tree1 == tree | simple$tree2 == tree, ]
View(test)
test <- test[order(test$distance), ] #order by distance
View(test)
test$distance
test$distance[-ncol(test)]
inc <- colnames(scbi.sub[, 6:ncol(scbi.sub)])[[i]]
scbi.sub$inc
colnames(scbi.sub)
inc <- colnames(scbi.sub) # [, 6:ncol(scbi.sub)])[[i]]
inc <- colnames(scbi.sub)[[i]] # [, 6:ncol(scbi.sub)])[[i]]
inc[[i>=6]]
i=2
inc <- colnames(scbi.sub)[[i]] # [, 6:ncol(scbi.sub)])[[i]]
inc-1
inc[-1]
inc <- colnames(scbi.sub)[[i-1]] # [, 6:ncol(scbi.sub)])[[i]]
k=1
inc_num <- colnames(scbi.sub[, 6:ncol(scbi.sub)])[[k]]
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/maps")
neil_map <- neil_list
neil_map$tag <- gsub("X", "", neil_map$tag)
neil_map$tag <- as.numeric(neil_map$tag)
##this should be fixed when 131352 is found with 2018 data!!!!
library(ggplot2)
library(rgdal)
library(broom) #for the tidy function
library(sf) #for mapping
library(ggthemes) #for removing graticules when making pdf
scbi_plot <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/20m_grid.shp")
deer <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/deer_exclosure_2011.shp")
roads <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/SCBI_roads_edits.shp")
streams <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/SCBI_streams_edits.shp")
NS_divide <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/maps/shapefiles/NS_divide1.shp")
#convert all shp to dataframe so that it can be used by ggplot
#if tidy isn't working, can also do: xxx_df <- as(xxx, "data.frame")
scbi_plot_df <- tidy(scbi_plot)
deer_df <- tidy(deer)
roads_df <- tidy(roads)
streams_df <- tidy(streams)
NS_divide_df <- tidy(NS_divide)
map <- ggplot() +
geom_path(data = scbi_plot_df, aes(x = long, y = lat, group = group))+
geom_path(data=roads_df, aes(x=long, y=lat, group=group),
color="#996600", linetype=2)+
geom_path(data=streams_df, aes(x=long, y=lat, group=group), color="blue")+
geom_path(data=deer_df, aes(x=long, y=lat, group=group), size=1.1)+
geom_point(data=neil_list, aes(x=NAD83_X, y=NAD83_Y), shape=19)+
geom_text(data=neil_list, aes(x=NAD83_X, y=NAD83_Y, label=tag),
size=3, hjust=1.25, nudge_y=-1, nudge_x=1, check_overlap=TRUE)+
theme(plot.title=element_text(vjust=0.1))+
coord_sf(crs = "crs = +proj=merc", xlim=c(747350,747800), ylim=c(4308500, 4309125))
library(pointRes)
library(dplR)
library(data.table)
##to be clear, I wrote this code before I realized that some of the work done in these loops had already been done in the outputs of res.comp (specifically out.select). However, since the code runs well, and I double-checked that it was giving the same outputs as analyzing out.select, I'm keeping it as is.
##4a. canopy ####
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/canopy_cores")
dirs_can <- dir("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/canopy_cores", pattern = "_canopy.rwl")
dirs_can <- dirs_can[dirs_can != "frni_canopy.rwl" & dirs_can != "frni_drop_canopy.rwl" & dirs_can != "caco_drop_canopy.rwl"]
sp_can <- gsub("_drop_canopy.rwl", "", dirs_can)
canopy <- list()
widths_can <- list()
canopy_table <- NULL
for (i in seq(along=dirs_can)){
for (j in seq(along=sp_can)){
if (i==j){
file <- dirs_can[[i]]
rings <- read.rwl(file) #read in rwl file
area <- bai.in(rings) #convert to bai.in
testr <- res.comp(area, nb.yrs=5, res.thresh.neg = 30, series.thresh = 50) #get resilience metrics
canopy[[i]] <- testr
widths_can[[i]] <- rings
testr_table <- data.frame(testr$out)
testr_table <- testr_table[testr_table$nb.series > 4, ] #remove where there are < 4 series
testr_table$sp <- sp_can[[j]]
testr_table$position <- "canopy"
canopy_table <- rbind(canopy_table, testr_table)
}
values <- paste0(sp_can, "_can_res")
names(canopy) <- values
values <- paste0(sp_can, "_canopy")
names(widths_can) <- values
##4b. subcanopy ####
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/subcanopy_cores")
dirs_subcan <- dir("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/tree_cores/chronologies/current_chronologies/complete/separated by canopy position/subcanopy_cores", pattern = "_subcanopy.rwl")
#dirs_subcan <- dirs_subcan[dirs_subcan != "frni_drop_subcanopy.rwl" & dirs_subcan != "caco_drop_subcanopy.rwl"]
sp_subcan <- gsub("_drop_subcanopy.rwl", "", dirs_subcan)
subcanopy <- list()
widths_sub <- list()
subcanopy_table <- NULL
for (i in seq(along=dirs_subcan)){
for (j in seq(along=sp_subcan)){
if (i==j){
file <- dirs_subcan[[i]]
rings <- read.rwl(file) #read in rwl file
area <- bai.in(rings) #convert to bai.in
test <- res.comp(area, nb.yrs=5, res.thresh.neg = 30, series.thresh = 50) #get resilience metrics
subcanopy[[i]] <- test
widths_sub[[i]] <- rings
test_table <- data.frame(test$out)
test_table <- test_table[test_table$nb.series > 4, ] #remove where there are < 4 series
test_table$sp <- sp_subcan[[j]]
test_table$position <- "subcanopy"
subcanopy_table <- rbind(subcanopy_table, test_table)
}
values_sub <- paste0(sp_subcan, "_subcan_res")
names(subcanopy) <- values_sub
values <- paste0(sp_subcan, "_subcanopy")
names(widths_sub) <- values
widths <- c(widths_can, widths_sub) #combine into one, then delete. For use in #5d
widths_can <- NULL
widths_subcan <- NULL
##4c. df for pointer years of all trees combined ####
full_ind <- rbind(canopy_table, subcanopy_table) #full table of indices for canopy and subcanopy cores
pointers <- full_ind[full_ind$nature == -1, ]
library(dplyr)
years_point <- count(pointers, vars=year) #counts the occurrences of each unique year
colnames(years_point) <- c("yr", "n.pointer")
years_point <- years_point[order(years_point$n.pointer, decreasing=TRUE), ]
#top drought years by species and canopy position
years_bysp <- pointers[pointers$year %in% c(1966, 1977, 1999), ]
years_bysp <- years_bysp[, c(1,13,14,2:12)]
years_bysp <- years_bysp[order(years_bysp$year, years_bysp$sp), ]
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/McGregor_climate-sensitivity-variation")
#write.csv(pointers, "occurrence_of_pointer_yrs.csv", row.names=FALSE)
##4d. resistance metrics for all trees ####
neil_list <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/McGregor_climate-sensitivity-variation/core_list_for_neil.csv", stringsAsFactors = FALSE)
neil_list$tag <- paste0("X", neil_list$tag) #to match the colnames of can_resist below
# pointer_years <- head(years_point$yr) #from above in #4c
# pointer_years <- pointer_years[!pointer_years %in% c(1911, 1947, 1991)]
pointer_years <- c(1964, 1966, 1977, 1999)
###canopy ####
#this loop says, for the different species in the list "canopy" (names(canopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(canopy)
trees_canopy <- NULL
for (i in seq(along=1:length(tag_n))){
can_resist <- data.frame(canopy[[i]]$resist)
years <- rownames(can_resist)
colnames(can_resist) <- gsub("A", "", colnames(can_resist))
tree_series <- colnames(can_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- can_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "canopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_canopy <- rbind(trees_canopy, change)
}
###subcanopy ####
#this loop says, for the different species in the list "subcanopy" (names(subcanopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(subcanopy)
trees_subcanopy <- NULL
for (i in seq(along=1:length(tag_n))){
sub_resist <- data.frame(subcanopy[[i]]$resist)
years <- rownames(sub_resist)
colnames(sub_resist) <- gsub("A", "", colnames(sub_resist))
tree_series <- colnames(sub_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- sub_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "subcanopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_subcanopy <- rbind(trees_subcanopy, change)
}
###rbind together ####
trees_all <- rbind(trees_canopy, trees_subcanopy)
trees_all$year <- as.numeric(trees_all$year)
#subset out NAs for resistance values (not necessary, bc lmm will automatically exclude them)
trees_all <- trees_all[!is.na(trees_all$resist.value), ]
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/maps")
neil_map <- neil_list
neil_map$tag <- gsub("X", "", neil_map$tag)
neil_map$tag <- as.numeric(neil_map$tag)
map <- ggplot() +
geom_path(data = scbi_plot_df, aes(x = long, y = lat, group = group))+
geom_path(data=roads_df, aes(x=long, y=lat, group=group),
color="#996600", linetype=2)+
geom_path(data=streams_df, aes(x=long, y=lat, group=group), color="blue")+
geom_path(data=deer_df, aes(x=long, y=lat, group=group), size=1.1)+
geom_point(data=neil_list, aes(x=NAD83_X, y=NAD83_Y), shape=19)+
geom_text(data=neil_list, aes(x=NAD83_X, y=NAD83_Y, label=tag),
size=3, hjust=1.25, nudge_y=-1, nudge_x=1, check_overlap=TRUE)+
theme(plot.title=element_text(vjust=0.1))+
coord_sf(crs = "crs = +proj=merc", xlim=c(747350,747800), ylim=c(4308500, 4309125))
library(geosphere)
streams_dd <- spTransform(streams, CRS("+proj=longlat +datum=WGS84"))
streams_dd_df <- tidy(streams_dd)
View(streams_dd_df)
View(roads)
library(gdistance)
library(sp)
library(spdep)
example(columbus)
plot(columbus)
install.packages("spdep")
library(sp)
library(spdep)
example(columbus)
plot(columbus)
library(rgeos)
?gDistance
View(neil_map)
neil_map_sub <- neil_map[, c(1:2,23:24)]
?SpatialPoints
neil_points <- SpatialPoints(neil_map_sub)
View(neil_map_sub)
neil_map_sub <- neil_map[, c(23:24,1:2)]
neil_points <- SpatialPoints(neil_map_sub)
pts = locator(20,type="p")
