theme_minimal()
esquisse:::esquisser()
ggplot(data = tlp_test) +
aes(x = position, y = tlp) +
geom_boxplot(fill = "#0c4c8a") +
theme_minimal() +
facet_wrap(vars(sp))
tlp_test <- trees_all[!duplicated(trees_all$tree), ]
tlp_test$tree <- as.numeric(tlp_test$tree)
ggplot(data = tlp_test) +
aes(x = position, y = tlp) +
geom_boxplot(fill = "#0c4c8a") +
theme_minimal() +
facet_wrap(vars(sp))
esquisse:::esquisser()
ggplot(data = tlp_test) +
aes(x = position, y = tlp) +
geom_boxplot(fill = "#0c4c8a") +
theme_minimal() +
facet_wrap(vars(year))
View(tlp_test)
ggplot(data = trees_all) +
aes(x = position, y = tlp) +
geom_boxplot(fill = "#0c4c8a") +
theme_minimal() +
facet_wrap(vars(year))
ggplot(data = tlp_test) +
aes(x = position, y = tlp) +
geom_boxplot(fill = "#0c4c8a") +
theme_minimal() +
# facet_wrap(vars(year))
##5b. add in ring porosity qualifications ####
ring_porosity <- data.frame("sp" = c("cagl",  "caovl", "cato", "fagr", "fram", "juni",  "litu",  "pist",  "qual",  "qupr",  "quru",  "quve", "caco", "frni"), "rp" = c("ring", "ring", "ring", "diffuse", "ring", "semi-ring", "diffuse", NA, "ring", "ring", "ring", "ring", "ring", "ring"))
ggplot(data = tlp_test) +
aes(x = position, y = tlp) +
geom_boxplot(fill = "#0c4c8a") +
theme_minimal()
summary(lm_new)
library(lme4)
library(AICcmodavg) #aictab function
library(car)
library(piecewiseSEM) #for R^2 values for all model outputs in a list
library(MuMIn) #for R^2 values of one model output
lm_new <- lm(resist.value ~ dbh_ln + tlp, data=trees_all, REML=FALSE)
##5d. add in dbh in each year 1999 ####
dbh <- trees_all[, c(1:4)]
dbh$dbh2013 <- elev$dbh[match(dbh$tree, elev$tag)]
#create df with bark thickness log values and intercept values from Krista's paper (supplemental info)
#https://besjournals.onlinelibrary.wiley.com/doi/epdf/10.1111/1365-2435.12470
#fagr does not have bark thickness measured because it is negligible
bark <- data.frame(
"sp" = c("acru", "fagr", "litu", "nysy", "caco", "cagl", "caovl", "cato", "fram", "juni", "qual", "qupr", "quru", "quve", "ulru"),
"bark_thick" = c(-2.564, 0, -0.659, -0.611, -1.917, -0.495, -2.504, -0.945, 0.318, -0.293, -1.231, -0.647, -0.789, 1.5, 1.133),
"intercept" = c(0.599, 0, 0.425, 0.413, 0.503, 0.316, 0.703, 0.396, 0.295, 0.385, 0.526, 0.423, 0.341, 0.053, -0.057))
dbh$bark_thick <- bark$bark_thick[match(dbh$sp, bark$sp)]
dbh$intercept <- bark$intercept[match(dbh$sp, bark$sp)]
#the main equation is based on ring widths. We have determined the equation to be
# rw(pointer_year) <- 0.5*dbh2013 - bark_thick*(dbh2013^intercept) - sum(rw(pointer_year):rw(end)). The first part of the equation is here. Summing the pointer years happens with the "q" df below in the loop.
dbh$rw_prelim <- (0.5*dbh$dbh2013) - (dbh$bark_thick*(dbh$dbh2013^dbh$intercept))
dbh$dbh_old <- "0" #in prep for below
dbh$dbh_old <- as.numeric(dbh$dbh_old)
for (i in seq(along=widths)){
df <- widths[[i]] #the list "widths" comes from #4a-4b
colnames(df) <- gsub("A", "", colnames(df)) #remove "A"
colnames(df) <- gsub("^0", "", colnames(df)) #remove leading 0
cols <- colnames(df) #define cols for below
colnames(df) <- gsub("^", "x", colnames(df)) #add "x" to make calling colnames below feasible
for (j in seq(along=cols)){
for (k in seq(along=colnames(df))){
ring_ind <- cols[[j]]
ring_col <- colnames(df)[[k]]
if(j==k){
#the output of this loop is 3 separate columns for each year's old dbh, hence why it is set to q as a dataframe before being combined below
q <- data.frame(sapply(pointer_years, function(x){
rw <- df[rownames(df)>=x, ]
ifelse(dbh$year == x & dbh$tree == ring_ind,
dbh$rw_prelim - sum(rw[, ring_col], na.rm=TRUE), 0)
}))
# q$dbh_old <- q[,1] +q[,2] + q[,3] #add columns together
q$dbh_old <- q[,1] +q[,2] + q[,3] + q[,4]
dbh$dbh_old <- dbh$dbh_old + q$dbh_old #combine with dbh
}
# check <- dbh[dbh$dbh_old == 0, ] #check if any tree was missed
trees_all$dbh_old <- dbh$dbh_old
trees_all$dbh_old <- ifelse(trees_all$dbh_old < 0, 0, trees_all$dbh_old)
trees_all$dbh_ln <- ifelse(trees_all$dbh_old == 0, NA, ln(trees_all$dbh_old))
lm_new <- lm(resist.value ~ dbh_ln + tlp, data=trees_all, REML=FALSE)
##5e. remove all NAs ####
trees_all <- trees_all[complete.cases(trees_all), ]
##5f. remove resistance values >2 ####
trees_all <- trees_all[trees_all$resist.value <=2,]
tlp_test <- trees_all[!duplicated(trees_all$tree), ]
tlp_test$tree <- as.numeric(tlp_test$tree)
ggplot(data = tlp_test) +
aes(x = position, y = tlp) +
geom_boxplot(fill = "#0c4c8a") +
theme_minimal()
###canopy ####
#this loop says, for the different species in the list "canopy" (names(canopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(canopy)
trees_canopy <- NULL
for (i in seq(along=1:length(tag_n))){
can_resist <- data.frame(canopy[[i]]$resist)
years <- rownames(can_resist)
colnames(can_resist) <- gsub("A", "", colnames(can_resist))
tree_series <- colnames(can_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- can_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "canopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_canopy <- rbind(trees_canopy, change)
}
###subcanopy ####
#this loop says, for the different species in the list "subcanopy" (names(subcanopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(subcanopy)
trees_subcanopy <- NULL
for (i in seq(along=1:length(tag_n))){
sub_resist <- data.frame(subcanopy[[i]]$resist)
years <- rownames(sub_resist)
colnames(sub_resist) <- gsub("A", "", colnames(sub_resist))
tree_series <- colnames(sub_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- sub_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "subcanopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_subcanopy <- rbind(trees_subcanopy, change)
}
###rbind together ####
trees_all <- rbind(trees_canopy, trees_subcanopy)
trees_all$year <- as.numeric(trees_all$year)
#subset out NAs for resistance values (not necessary, bc lmm will automatically exclude them)
trees_all <- trees_all[!is.na(trees_all$resist.value), ]
turgor <- data.frame("sp" = c("cagl", "caovl", "fagr", "fram", "juni", "litu", "pist", "qual", "qupr", "quru", "quve", "caco", "cato", "frni"), "tlp" = c(-2.1282533, -2.24839333, -2.57164, -2.1012133, -2.75936, -1.9212933, NA, -2.58412, -2.3601733, -2.6395867, -2.3879067, -2.1324133, -2.31424, NA))
trees_all$tlp <- turgor$tlp[match(trees_all$sp, turgor$sp)]
##5d. add in dbh in each year 1999 ####
dbh <- trees_all[, c(1:4)]
dbh$dbh2013 <- elev$dbh[match(dbh$tree, elev$tag)]
#create df with bark thickness log values and intercept values from Krista's paper (supplemental info)
#https://besjournals.onlinelibrary.wiley.com/doi/epdf/10.1111/1365-2435.12470
#fagr does not have bark thickness measured because it is negligible
bark <- data.frame(
"sp" = c("acru", "fagr", "litu", "nysy", "caco", "cagl", "caovl", "cato", "fram", "juni", "qual", "qupr", "quru", "quve", "ulru"),
"bark_thick" = c(-2.564, 0, -0.659, -0.611, -1.917, -0.495, -2.504, -0.945, 0.318, -0.293, -1.231, -0.647, -0.789, 1.5, 1.133),
"intercept" = c(0.599, 0, 0.425, 0.413, 0.503, 0.316, 0.703, 0.396, 0.295, 0.385, 0.526, 0.423, 0.341, 0.053, -0.057))
dbh$bark_thick <- bark$bark_thick[match(dbh$sp, bark$sp)]
dbh$intercept <- bark$intercept[match(dbh$sp, bark$sp)]
#the main equation is based on ring widths. We have determined the equation to be
# rw(pointer_year) <- 0.5*dbh2013 - bark_thick*(dbh2013^intercept) - sum(rw(pointer_year):rw(end)). The first part of the equation is here. Summing the pointer years happens with the "q" df below in the loop.
dbh$rw_prelim <- (0.5*dbh$dbh2013) - (dbh$bark_thick*(dbh$dbh2013^dbh$intercept))
dbh$dbh_old <- "0" #in prep for below
dbh$dbh_old <- as.numeric(dbh$dbh_old)
for (i in seq(along=widths)){
df <- widths[[i]] #the list "widths" comes from #4a-4b
colnames(df) <- gsub("A", "", colnames(df)) #remove "A"
colnames(df) <- gsub("^0", "", colnames(df)) #remove leading 0
cols <- colnames(df) #define cols for below
colnames(df) <- gsub("^", "x", colnames(df)) #add "x" to make calling colnames below feasible
for (j in seq(along=cols)){
for (k in seq(along=colnames(df))){
ring_ind <- cols[[j]]
ring_col <- colnames(df)[[k]]
if(j==k){
#the output of this loop is 3 separate columns for each year's old dbh, hence why it is set to q as a dataframe before being combined below
q <- data.frame(sapply(pointer_years, function(x){
rw <- df[rownames(df)>=x, ]
ifelse(dbh$year == x & dbh$tree == ring_ind,
dbh$rw_prelim - sum(rw[, ring_col], na.rm=TRUE), 0)
}))
# q$dbh_old <- q[,1] +q[,2] + q[,3] #add columns together
q$dbh_old <- q[,1] +q[,2] + q[,3] + q[,4]
dbh$dbh_old <- dbh$dbh_old + q$dbh_old #combine with dbh
}
# check <- dbh[dbh$dbh_old == 0, ] #check if any tree was missed
trees_all$dbh_old <- dbh$dbh_old
trees_all$dbh_old <- ifelse(trees_all$dbh_old < 0, 0, trees_all$dbh_old)
trees_all$dbh_ln <- ifelse(trees_all$dbh_old == 0, NA, ln(trees_all$dbh_old))
##5e. remove all NAs ####
trees_all <- trees_all[complete.cases(trees_all), ]
##5f. remove resistance values >2 ####
trees_all <- trees_all[trees_all$resist.value <=2,]
View(dbh)
###canopy ####
#this loop says, for the different species in the list "canopy" (names(canopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(canopy)
trees_canopy <- NULL
for (i in seq(along=1:length(tag_n))){
can_resist <- data.frame(canopy[[i]]$resist)
years <- rownames(can_resist)
colnames(can_resist) <- gsub("A", "", colnames(can_resist))
tree_series <- colnames(can_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- can_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "canopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_canopy <- rbind(trees_canopy, change)
}
###subcanopy ####
#this loop says, for the different species in the list "subcanopy" (names(subcanopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(subcanopy)
trees_subcanopy <- NULL
for (i in seq(along=1:length(tag_n))){
sub_resist <- data.frame(subcanopy[[i]]$resist)
years <- rownames(sub_resist)
colnames(sub_resist) <- gsub("A", "", colnames(sub_resist))
tree_series <- colnames(sub_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- sub_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "subcanopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_subcanopy <- rbind(trees_subcanopy, change)
}
###rbind together ####
trees_all <- rbind(trees_canopy, trees_subcanopy)
trees_all$year <- as.numeric(trees_all$year)
#subset out NAs for resistance values (not necessary, bc lmm will automatically exclude them)
trees_all <- trees_all[!is.na(trees_all$resist.value), ]
##5a. add in turgor loss point values ####
#add in tlp values (from Krista github issue #6 https://github.com/SCBI-ForestGEO/McGregor_climate-sensitivity-variation/issues/6)
turgor <- data.frame("sp" = c("cagl", "caovl", "fagr", "fram", "juni", "litu", "pist", "qual", "qupr", "quru", "quve", "caco", "cato", "frni"), "tlp" = c(-2.1282533, -2.24839333, -2.57164, -2.1012133, -2.75936, -1.9212933, NA, -2.58412, -2.3601733, -2.6395867, -2.3879067, -2.1324133, -2.31424, NA))
trees_all$tlp <- turgor$tlp[match(trees_all$sp, turgor$sp)]
#tlp for pist is NA. Removing pist (because of the tlp NA) gives different results.
#trees_all <- trees_all[!trees_all$sp == "pist", ]
tlp_test <- trees_all[!duplicated(trees_all$tree), ]
tlp_test$tree <- as.numeric(tlp_test$tree)
ggplot(data = tlp_test) +
aes(x = position, y = tlp) +
geom_boxplot(fill = "#0c4c8a") +
theme_minimal()
# facet_wrap(vars(year))
##5c. add in elevation data ####
elev <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/elevation/full_stem_elevation_2013.csv")
trees_all$elev_m <- elev$dem_sigeo[match(trees_all$tree, elev$tag)]
##5d. add in dbh in each year 1999 ####
dbh <- trees_all[, c(1:4)]
dbh$dbh2013 <- elev$dbh[match(dbh$tree, elev$tag)]
#create df with bark thickness log values and intercept values from Krista's paper (supplemental info)
#https://besjournals.onlinelibrary.wiley.com/doi/epdf/10.1111/1365-2435.12470
#fagr does not have bark thickness measured because it is negligible
bark <- data.frame(
"sp" = c("acru", "fagr", "litu", "nysy", "caco", "cagl", "caovl", "cato", "fram", "juni", "qual", "qupr", "quru", "quve", "ulru"),
"bark_thick" = c(-2.564, 0, -0.659, -0.611, -1.917, -0.495, -2.504, -0.945, 0.318, -0.293, -1.231, -0.647, -0.789, 1.5, 1.133),
"intercept" = c(0.599, 0, 0.425, 0.413, 0.503, 0.316, 0.703, 0.396, 0.295, 0.385, 0.526, 0.423, 0.341, 0.053, -0.057))
dbh$bark_thick <- bark$bark_thick[match(dbh$sp, bark$sp)]
dbh$intercept <- bark$intercept[match(dbh$sp, bark$sp)]
#the main equation is based on ring widths. We have determined the equation to be
# rw(pointer_year) <- 0.5*dbh2013 - bark_thick*(dbh2013^intercept) - sum(rw(pointer_year):rw(end)). The first part of the equation is here. Summing the pointer years happens with the "q" df below in the loop.
dbh$rw_prelim <- (0.5*dbh$dbh2013) - (dbh$bark_thick*(dbh$dbh2013^dbh$intercept))
dbh$dbh_old <- "0" #in prep for below
dbh$dbh_old <- as.numeric(dbh$dbh_old)
for (i in seq(along=widths)){
df <- widths[[i]] #the list "widths" comes from #4a-4b
colnames(df) <- gsub("A", "", colnames(df)) #remove "A"
colnames(df) <- gsub("^0", "", colnames(df)) #remove leading 0
cols <- colnames(df) #define cols for below
colnames(df) <- gsub("^", "x", colnames(df)) #add "x" to make calling colnames below feasible
for (j in seq(along=cols)){
for (k in seq(along=colnames(df))){
ring_ind <- cols[[j]]
ring_col <- colnames(df)[[k]]
if(j==k){
#the output of this loop is 3 separate columns for each year's old dbh, hence why it is set to q as a dataframe before being combined below
q <- data.frame(sapply(pointer_years, function(x){
rw <- df[rownames(df)>=x, ]
ifelse(dbh$year == x & dbh$tree == ring_ind,
dbh$rw_prelim - sum(rw[, ring_col], na.rm=TRUE), 0)
}))
# q$dbh_old <- q[,1] +q[,2] + q[,3] #add columns together
q$dbh_old <- q[,1] +q[,2] + q[,3] + q[,4]
dbh$dbh_old <- dbh$dbh_old + q$dbh_old #combine with dbh
}
# check <- dbh[dbh$dbh_old == 0, ] #check if any tree was missed
trees_all$dbh_old <- dbh$dbh_old
trees_all$dbh_old <- ifelse(trees_all$dbh_old < 0, 0, trees_all$dbh_old)
trees_all$dbh_ln <- ifelse(trees_all$dbh_old == 0, NA, ln(trees_all$dbh_old))
##5e. remove all NAs ####
trees_all <- trees_all[complete.cases(trees_all), ]
##5f. remove resistance values >2 ####
trees_all <- trees_all[trees_all$resist.value <=2,]
##########################################################################################
#5. add in climate and growth variables ####
library(SciViews)
###canopy ####
#this loop says, for the different species in the list "canopy" (names(canopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(canopy)
trees_canopy <- NULL
for (i in seq(along=1:length(tag_n))){
can_resist <- data.frame(canopy[[i]]$resist)
years <- rownames(can_resist)
colnames(can_resist) <- gsub("A", "", colnames(can_resist))
tree_series <- colnames(can_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- can_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "canopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_canopy <- rbind(trees_canopy, change)
}
###subcanopy ####
#this loop says, for the different species in the list "subcanopy" (names(subcanopy)), create a dataframe of only the resistance index. Make a list of the colnames, which are the individual trees. Then, assign species identifiers for each one from Neil's core list, subset by the defined pointer years, and melt the data before rbinding.
tag_n <- names(subcanopy)
trees_subcanopy <- NULL
for (i in seq(along=1:length(tag_n))){
sub_resist <- data.frame(subcanopy[[i]]$resist)
years <- rownames(sub_resist)
colnames(sub_resist) <- gsub("A", "", colnames(sub_resist))
tree_series <- colnames(sub_resist)
# for (j in seq(along=tree_series)){
#  trees <- tree_series[[j]]
ind <- sub_resist
ind_neil <- neil_list[neil_list$tag %in% tree_series, ]
#  colnames(ind) <- trees
ind$year <- years
ind$sp <- unique(ind_neil$sp)
ind$position <- "subcanopy"
ind <- ind[ind$year %in% pointer_years, ]
change <- melt(ind)
setnames(change, old=c("variable", "value"), new=c("tree", "resist.value"))
change$tree <- gsub("X", "", change$tree)
change$tree <- gsub("^0", "", change$tree)
trees_subcanopy <- rbind(trees_subcanopy, change)
}
###rbind together ####
trees_all <- rbind(trees_canopy, trees_subcanopy)
trees_all$year <- as.numeric(trees_all$year)
#subset out NAs for resistance values (not necessary, bc lmm will automatically exclude them)
trees_all <- trees_all[!is.na(trees_all$resist.value), ]
library(SciViews)
##5a. add in turgor loss point values ####
#add in tlp values (from Krista github issue #6 https://github.com/SCBI-ForestGEO/McGregor_climate-sensitivity-variation/issues/6)
turgor <- data.frame("sp" = c("cagl", "caovl", "fagr", "fram", "juni", "litu", "pist", "qual", "qupr", "quru", "quve", "caco", "cato", "frni"), "tlp" = c(-2.1282533, -2.24839333, -2.57164, -2.1012133, -2.75936, -1.9212933, NA, -2.58412, -2.3601733, -2.6395867, -2.3879067, -2.1324133, -2.31424, NA))
trees_all$tlp <- turgor$tlp[match(trees_all$sp, turgor$sp)]
#tlp for pist is NA. Removing pist (because of the tlp NA) gives different results.
#trees_all <- trees_all[!trees_all$sp == "pist", ]
tlp_test <- trees_all[!duplicated(trees_all$tree), ]
tlp_test$tree <- as.numeric(tlp_test$tree)
ggplot(data = tlp_test) +
aes(x = position, y = tlp) +
geom_boxplot(fill = "#0c4c8a") +
theme_minimal()
# facet_wrap(vars(year))
##5b. add in ring porosity qualifications ####
ring_porosity <- data.frame("sp" = c("cagl",  "caovl", "cato", "fagr", "fram", "juni",  "litu",  "pist",  "qual",  "qupr",  "quru",  "quve", "caco", "frni"), "rp" = c("ring", "ring", "ring", "diffuse", "ring", "semi-ring", "diffuse", NA, "ring", "ring", "ring", "ring", "ring", "ring"))
trees_all$rp <- ring_porosity$rp[match(trees_all$sp, ring_porosity$sp)]
##5c. add in elevation data ####
elev <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/elevation/full_stem_elevation_2013.csv")
trees_all$elev_m <- elev$dem_sigeo[match(trees_all$tree, elev$tag)]
##5d. add in dbh in each year 1999 ####
dbh <- trees_all[, c(1:4)]
dbh$dbh2013 <- elev$dbh[match(dbh$tree, elev$tag)]
#create df with bark thickness log values and intercept values from Krista's paper (supplemental info)
#https://besjournals.onlinelibrary.wiley.com/doi/epdf/10.1111/1365-2435.12470
#fagr does not have bark thickness measured because it is negligible
bark <- data.frame(
"sp" = c("acru", "fagr", "litu", "nysy", "caco", "cagl", "caovl", "cato", "fram", "juni", "qual", "qupr", "quru", "quve", "ulru"),
"bark_thick" = c(-2.564, 0, -0.659, -0.611, -1.917, -0.495, -2.504, -0.945, 0.318, -0.293, -1.231, -0.647, -0.789, 1.5, 1.133),
"intercept" = c(0.599, 0, 0.425, 0.413, 0.503, 0.316, 0.703, 0.396, 0.295, 0.385, 0.526, 0.423, 0.341, 0.053, -0.057))
dbh$bark_thick <- bark$bark_thick[match(dbh$sp, bark$sp)]
dbh$intercept <- bark$intercept[match(dbh$sp, bark$sp)]
#the main equation is based on ring widths. We have determined the equation to be
# rw(pointer_year) <- 0.5*dbh2013 - bark_thick*(dbh2013^intercept) - sum(rw(pointer_year):rw(end)). The first part of the equation is here. Summing the pointer years happens with the "q" df below in the loop.
dbh$rw_prelim <- (0.5*dbh$dbh2013) - (dbh$bark_thick*(dbh$dbh2013^dbh$intercept))
dbh$dbh_old <- "0" #in prep for below
dbh$dbh_old <- as.numeric(dbh$dbh_old)
for (i in seq(along=widths)){
df <- widths[[i]] #the list "widths" comes from #4a-4b
colnames(df) <- gsub("A", "", colnames(df)) #remove "A"
colnames(df) <- gsub("^0", "", colnames(df)) #remove leading 0
cols <- colnames(df) #define cols for below
colnames(df) <- gsub("^", "x", colnames(df)) #add "x" to make calling colnames below feasible
for (j in seq(along=cols)){
for (k in seq(along=colnames(df))){
ring_ind <- cols[[j]]
ring_col <- colnames(df)[[k]]
if(j==k){
#the output of this loop is 3 separate columns for each year's old dbh, hence why it is set to q as a dataframe before being combined below
q <- data.frame(sapply(pointer_years, function(x){
rw <- df[rownames(df)>=x, ]
ifelse(dbh$year == x & dbh$tree == ring_ind,
dbh$rw_prelim - sum(rw[, ring_col], na.rm=TRUE), 0)
}))
# q$dbh_old <- q[,1] +q[,2] + q[,3] #add columns together
q$dbh_old <- q[,1] +q[,2] + q[,3] + q[,4]
dbh$dbh_old <- dbh$dbh_old + q$dbh_old #combine with dbh
}
# check <- dbh[dbh$dbh_old == 0, ] #check if any tree was missed
trees_all$dbh_old <- dbh$dbh_old
trees_all$dbh_old <- ifelse(trees_all$dbh_old < 0, 0, trees_all$dbh_old)
trees_all$dbh_ln <- ifelse(trees_all$dbh_old == 0, NA, ln(trees_all$dbh_old))
##5e. remove all NAs ####
trees_all <- trees_all[complete.cases(trees_all), ]
##5f. remove resistance values >2 ####
trees_all <- trees_all[trees_all$resist.value <=2,]
tlp_test <- trees_all[!duplicated(trees_all$tree), ]
tlp_test$tree <- as.numeric(tlp_test$tree)
ggplot(data = tlp_test) +
aes(x = position, y = tlp) +
geom_boxplot(fill = "#0c4c8a") +
theme_minimal()
plot(trees_all$tlp, trees_all$dbh_ln)
lm(tlp ~ dbh_ln, data=trees_all)
plot(lm(tlp ~ dbh_ln, data=trees_all))
lm_new <- lm(resist.value ~ dbh_ln + tlp, data=trees_all, REML=FALSE)
summary(lm_new)
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/maps")
#we are using dendro_trees for this code as opposed to "scbi.dendroAll_YEAR.csv" because
#1. dendro_trees reflects the data in the all of the YEAR files and
#2. dendro_trees has the necessary mapping information in lx/ly, gx/gy, NAD83X/Y, AND lat/lon in decimal degrees.
##THUS make sure dendro_trees is updated when making new maps
dendro_trees <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/dendro_trees.csv")
#to start off, filter by all the trees that are alive as of the end of last year's fall survey.
bands_2019 <- dendro_trees[is.na(dendro_trees$mortality.year), ]
bands_2019 <- bands_2019[complete.cases(bands_2019[, c("NAD83_X", "NAD83_Y")]),] # remove one tree with missing coordinates
##this should be fixed when 131352 is found with 2018 data!!!!
library(ggplot2)
library(rgdal)
library(broom) #for the tidy function
library(sf) #for mapping
library(ggthemes) #for removing graticules when making pdf
scbi_plot <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/20m_grid.shp")
deer <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/deer_exclosure_2011.shp")
roads <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/SCBI_roads_edits.shp")
streams <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/SCBI-ForestGEO-Data/spatial_data/shapefiles/SCBI_streams_edits.shp")
contour_10m <- readOGR("V:/SIGEO/GIS_data/dendroband surveys/dendroband intraannual/contour10m_SIGEO_clipped.shp")
survey_areas <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/maps/shapefiles/biannual_survey_areas.shp")
NS_divide <- readOGR("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/resources/maps/shapefiles/NS_divide1.shp")
#convert all shp to dataframe so that it can be used by ggplot
#if tidy isn't working, can also do: xxx_df <- as(xxx, "data.frame")
scbi_plot_df <- tidy(scbi_plot)
deer_df <- tidy(deer)
roads_df <- tidy(roads)
streams_df <- tidy(streams)
survey_areas_df <- tidy(survey_areas)
NS_divide_df <- tidy(NS_divide)
contour_10m_df <- tidy(contour_10m)
#x and y give the x/yposition on the plot; sprintf says to add 0 for single digits, the x/y=seq(...,length.out) says fit the label within these parameters, fitting the length of the label evenly.
##this code adds the row and column numbers based on coordinates
rows <- annotate("text", x = seq(747350, 747365, length.out = 32), y = seq(4309125, 4308505, length.out = 32), label = sprintf("%02d", 32:1) , size=5.25, color="black")
cols <- annotate("text", x = seq(747390, 747765, length.out = 20), y = seq(4308495, 4308505, length.out = 20), label = sprintf("%02d", 1:20), size=5.4, color="black")
#these are the numbers for the survey areas, following the survey_area shp border areas
section1 <- annotate("text", x= 747730, y= 4308705, label = "1", size=6, fontface=2)
section2 <- annotate("text", x= 747630, y= 4308683, label = "2", size=6, fontface=2)
section3 <- annotate("text", x= 747450, y= 4308717, label = "3", size=6, fontface=2)
section4 <- annotate("text", x= 747445, y= 4309000, label = "4", size=6, fontface=2)
section5 <- annotate("text", x= 747567, y= 4308920, label = "5", size=6, fontface=2)
section6 <- annotate("text", x= 747687, y= 4308923, label = "6", size=6, fontface=2)
section7 <- annotate("text", x= 747520, y= 4309100, label = "7", size=6, fontface=2)
section8 <- annotate("text", x= 747605, y= 4309100, label = "8", size=6, fontface=2)
section9 <- annotate("text", x= 747725, y= 4309045, label = "9", size=6, fontface=2)
#biannual survey map ####
map <- ggplot() +
geom_path(data = scbi_plot_df, aes(x = long, y = lat, group = group))+
geom_path(data=roads_df, aes(x=long, y=lat, group=group),
color="#996600", linetype=2)+
geom_path(data=streams_df, aes(x=long, y=lat, group=group), color="blue")+
geom_path(data=survey_areas_df, aes(x=long, y=lat, group=group), size=1.1)+
geom_point(data=bands_2019, aes(x=NAD83_X, y=NAD83_Y), shape=19)+
geom_text(data=bands_2019, aes(x=NAD83_X, y=NAD83_Y, label=tag),
size=3, hjust=1.25, nudge_y=-1, nudge_x=1, check_overlap=TRUE)+
labs(title="Dendrobands_Biannual_2019")+
theme(plot.title=element_text(vjust=0.1))+
coord_sf(crs = "crs = +proj=merc", xlim=c(747350,747800), ylim=c(4308500, 4309125))
map
map +
rows +
cols +
section1 + section2 + section3 + section4 + section5 + section6 + section7 + section8 + section9 +
theme_map()+
theme(panel.grid.major = element_line(colour = 'transparent'))
