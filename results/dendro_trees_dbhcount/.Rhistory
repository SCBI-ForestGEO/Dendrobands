data_surveys$dbh <- as.numeric(data_surveys$dbh)
dbhmax <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), max)
dbhmin <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), min)
dbhavg <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), mean)
names(dbhmax) <- c("sp", "dbhmax.mm")
names(dbhmin) <- c("sp", "dbhmin.mm")
names(dbhavg) <- c("sp", "dbhavg.mm")
is.num <- sapply(dbhavg,is.numeric)
dbhavg[is.num] <- lapply(dbhavg[is.num], round, 1)
#create data.frame with count of sp per survey
library(data.table)
data_01<-subset(data_2011,data_2011$survey.ID=='2011.01') #get all sp
countbi<- addmargins(table(data_01$sp, data_01$biannual),1)
countbi<- as.data.frame.matrix(countbi)
setDT(countbi, keep.rownames=TRUE)[]
colnames(countbi) <- c("sp", "biannual.n")
countintra<- addmargins(table(data_01$sp, data_01$intraannual==1), 1)
countintra<- as.data.frame.matrix(countintra)
setDT(countintra, keep.rownames=TRUE)[]
colnames(countintra) <- c("sp", "wrong", "intraannual.n")
countintra$wrong <- NULL
#merge the data.frames together
library(tidyverse)
#have to make two separate dataframes, then merge them together to make sure the "Sum" row is kept
data_count <- merge(countbi, countintra, by="sp")
data_num <- list(data_trees,dbhmin,dbhmax,dbhavg) %>% reduce(left_join, by="sp")
data_merged <- merge(data_count, data_num, by="sp", all.x=TRUE)
data_2011 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/2011/scbi.dendroAll_2011.csv")
#subset by the last survey from the year
data_surveys<- subset(data_2011,data_2011$survey.ID=='2011.23' & data_2011$status=='alive') #get rid of '0' values for minimum
data_trees <- data_2011[!duplicated(data_2011["sp"]),]
data_trees <- data_trees[c("sp")] #list that shows all sp alive and dead
#make data.frames with the dbhmax,min,mean by sp
data_surveys$dbh <- as.numeric(data_surveys$dbh)
dbhmax <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), max)
dbhmin <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), min)
dbhavg <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), mean)
names(dbhmax) <- c("sp", "dbhmax.mm")
names(dbhmin) <- c("sp", "dbhmin.mm")
names(dbhavg) <- c("sp", "dbhavg.mm")
is.num <- sapply(dbhavg,is.numeric)
dbhavg[is.num] <- lapply(dbhavg[is.num], round, 1)
#create data.frame with count of sp per survey
library(data.table)
data_01<-subset(data_2011,data_2011$survey.ID=='2011.01') #get all sp
countbi<- addmargins(table(data_01$sp, data_01$biannual),1)
countbi<- as.data.frame.matrix(countbi)
setDT(countbi, keep.rownames=TRUE)[]
colnames(countbi) <- c("sp", "biannual.n")
countintra<- addmargins(table(data_01$sp, data_01$intraannual==1), 1)
countintra<- as.data.frame.matrix(countintra)
setDT(countintra, keep.rownames=TRUE)[]
colnames(countintra) <- c("sp", "wrong", "intraannual.n")
countintra$wrong <- NULL
#merge the data.frames together
library(tidyverse)
#have to make two separate dataframes, then merge them together to make sure the "Sum" row is kept
data_count <- merge(countbi, countintra, by="sp")
data_num <- list(data_trees,dbhmin,dbhmax,dbhavg) %>% reduce(left_join, by="sp")
data_merged <- merge(data_count, data_num, by="sp", all.x=TRUE)
data_merged <- data_merged[order(data_merged$sp),]
View(data_merged)
##reorder to make "Sum" row be last. These numbers may change depending on if a tree has been fully removed from the survey
data_merged <- data_merged[c(1:20,22,23,21),]
write.csv(data_merged, "dendro_trees_2011_min_max_mean_dbh.csv", row.names=FALSE)
setwd("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/results/dendro_trees_dbhcount")
data_2013 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/2013/scbi.dendroAll_2013.csv")
#subset by the last survey from the year
data_surveys<- subset(data_2013,data_2013$survey.ID=='2013.23' & data_2013$status=='alive') #get rid of '0' values for minimum
data_trees <- data_2013[!duplicated(data_2013["sp"]),]
data_trees <- data_trees[c("sp")] #list that shows all sp alive and dead
#make data.frames with the dbhmax,min,mean by sp
data_surveys$dbh <- as.numeric(data_surveys$dbh)
dbhmax <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), max)
dbhmin <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), min)
dbhavg <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), mean)
names(dbhmax) <- c("sp", "dbhmax.mm")
names(dbhmin) <- c("sp", "dbhmin.mm")
names(dbhavg) <- c("sp", "dbhavg.mm")
is.num <- sapply(dbhavg,is.numeric)
dbhavg[is.num] <- lapply(dbhavg[is.num], round, 1)
#create data.frame with count of sp per survey
library(data.table)
data_01<-subset(data_2013,data_2013$survey.ID=='2013.01') #get all sp
countbi<- addmargins(table(data_01$sp, data_01$biannual),1)
countbi<- as.data.frame.matrix(countbi)
setDT(countbi, keep.rownames=TRUE)[]
colnames(countbi) <- c("sp", "biannual.n")
countintra<- addmargins(table(data_01$sp, data_01$intraannual==1), 1)
countintra<- as.data.frame.matrix(countintra)
setDT(countintra, keep.rownames=TRUE)[]
colnames(countintra) <- c("sp", "wrong", "intraannual.n")
countintra$wrong <- NULL
#merge the data.frames together
library(tidyverse)
#have to make two separate dataframes, then merge them together to make sure the "Sum" row is kept
data_count <- merge(countbi, countintra, by="sp")
data_num <- list(data_trees,dbhmin,dbhmax,dbhavg) %>% reduce(left_join, by="sp")
data_merged <- merge(data_count, data_num, by="sp", all.x=TRUE)
data_merged <- data_merged[order(data_merged$sp),]
data_2013 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/2013/scbi.dendroAll_2013.csv")
#subset by the last survey from the year
data_surveys<- subset(data_2013,data_2013$survey.ID=='2013.16' & data_2013$status=='alive') #get rid of '0' values for minimum
data_trees <- data_2013[!duplicated(data_2013["sp"]),]
data_trees <- data_trees[c("sp")] #list that shows all sp alive and dead
#make data.frames with the dbhmax,min,mean by sp
data_surveys$dbh <- as.numeric(data_surveys$dbh)
dbhmax <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), max)
dbhmin <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), min)
dbhavg <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), mean)
names(dbhmax) <- c("sp", "dbhmax.mm")
names(dbhmin) <- c("sp", "dbhmin.mm")
names(dbhavg) <- c("sp", "dbhavg.mm")
is.num <- sapply(dbhavg,is.numeric)
dbhavg[is.num] <- lapply(dbhavg[is.num], round, 1)
#create data.frame with count of sp per survey
library(data.table)
data_01<-subset(data_2013,data_2013$survey.ID=='2013.01') #get all sp
countbi<- addmargins(table(data_01$sp, data_01$biannual),1)
countbi<- as.data.frame.matrix(countbi)
setDT(countbi, keep.rownames=TRUE)[]
colnames(countbi) <- c("sp", "biannual.n")
countintra<- addmargins(table(data_01$sp, data_01$intraannual==1), 1)
countintra<- as.data.frame.matrix(countintra)
setDT(countintra, keep.rownames=TRUE)[]
colnames(countintra) <- c("sp", "wrong", "intraannual.n")
countintra$wrong <- NULL
#merge the data.frames together
library(tidyverse)
#have to make two separate dataframes, then merge them together to make sure the "Sum" row is kept
data_count <- merge(countbi, countintra, by="sp")
data_num <- list(data_trees,dbhmin,dbhmax,dbhavg) %>% reduce(left_join, by="sp")
data_merged <- merge(data_count, data_num, by="sp", all.x=TRUE)
data_merged <- data_merged[order(data_merged$sp),]
View(data_merged)
##reorder to make "Sum" row be last. These numbers may change depending on if a tree has been fully removed from the survey
data_merged <- data_merged[c(1:22,24,25,23),]
View(data_merged)
data_2013 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/2013/scbi.dendroAll_2013.csv")
#subset by the last survey from the year
data_surveys<- subset(data_2013,data_2013$survey.ID=='2013.16') #& data_2013$status=='alive') #get rid of '0' values for minimum
data_trees <- data_2013[!duplicated(data_2013["sp"]),]
data_trees <- data_trees[c("sp")] #list that shows all sp alive and dead
#make data.frames with the dbhmax,min,mean by sp
data_surveys$dbh <- as.numeric(data_surveys$dbh)
dbhmax <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), max)
dbhmin <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), min)
dbhavg <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), mean)
names(dbhmax) <- c("sp", "dbhmax.mm")
names(dbhmin) <- c("sp", "dbhmin.mm")
names(dbhavg) <- c("sp", "dbhavg.mm")
is.num <- sapply(dbhavg,is.numeric)
dbhavg[is.num] <- lapply(dbhavg[is.num], round, 1)
#create data.frame with count of sp per survey
library(data.table)
data_01<-subset(data_2013,data_2013$survey.ID=='2013.01') #get all sp
countbi<- addmargins(table(data_01$sp, data_01$biannual),1)
countbi<- as.data.frame.matrix(countbi)
setDT(countbi, keep.rownames=TRUE)[]
colnames(countbi) <- c("sp", "biannual.n")
countintra<- addmargins(table(data_01$sp, data_01$intraannual==1), 1)
countintra<- as.data.frame.matrix(countintra)
setDT(countintra, keep.rownames=TRUE)[]
colnames(countintra) <- c("sp", "wrong", "intraannual.n")
countintra$wrong <- NULL
#merge the data.frames together
library(tidyverse)
#have to make two separate dataframes, then merge them together to make sure the "Sum" row is kept
data_count <- merge(countbi, countintra, by="sp")
data_num <- list(data_trees,dbhmin,dbhmax,dbhavg) %>% reduce(left_join, by="sp")
data_merged <- merge(data_count, data_num, by="sp", all.x=TRUE)
data_merged <- data_merged[order(data_merged$sp),]
##reorder to make "Sum" row be last. These numbers may change depending on if a tree has been fully removed from the survey
data_merged <- data_merged[c(1:22,24,25,23),]
View(data_merged)
data_2013 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/2013/scbi.dendroAll_2013.csv")
#subset by the last survey from the year
data_surveys<- subset(data_2013,data_2013$survey.ID=='2013.16') #& data_2013$status=='alive') #get rid of '0' values for minimum
data_trees <- data_2013[!duplicated(data_2013["sp"]),]
data_trees <- data_trees[c("sp")] #list that shows all sp alive and dead
#make data.frames with the dbhmax,min,mean by sp
data_surveys$dbh <- as.numeric(data_surveys$dbh)
dbhmax <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), max)
dbhmin <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), min)
dbhavg <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), mean)
names(dbhmax) <- c("sp", "dbhmax.mm")
names(dbhmin) <- c("sp", "dbhmin.mm")
names(dbhavg) <- c("sp", "dbhavg.mm")
is.num <- sapply(dbhavg,is.numeric)
dbhavg[is.num] <- lapply(dbhavg[is.num], round, 1)
#create data.frame with count of sp per survey
library(data.table)
data_01<-subset(data_2013,data_2013$survey.ID=='2013.16') #get all sp
countbi<- addmargins(table(data_01$sp, data_01$biannual),1)
countbi<- as.data.frame.matrix(countbi)
setDT(countbi, keep.rownames=TRUE)[]
colnames(countbi) <- c("sp", "biannual.n")
countintra<- addmargins(table(data_01$sp, data_01$intraannual==1), 1)
countintra<- as.data.frame.matrix(countintra)
setDT(countintra, keep.rownames=TRUE)[]
colnames(countintra) <- c("sp", "wrong", "intraannual.n")
countintra$wrong <- NULL
#merge the data.frames together
library(tidyverse)
#have to make two separate dataframes, then merge them together to make sure the "Sum" row is kept
data_count <- merge(countbi, countintra, by="sp")
data_num <- list(data_trees,dbhmin,dbhmax,dbhavg) %>% reduce(left_join, by="sp")
data_merged <- merge(data_count, data_num, by="sp", all.x=TRUE)
data_merged <- data_merged[order(data_merged$sp),]
##reorder to make "Sum" row be last. These numbers may change depending on if a tree has been fully removed from the survey
data_merged <- data_merged[c(1:22,24,25,23),]
View(data_merged)
write.csv(data_merged, "dendro_trees_2013_min_max_mean_dbh.csv", row.names=FALSE)
data_2014 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/2014/scbi.dendroAll_2014.csv")
#subset by the last survey from the year
data_surveys<- subset(data_2014,data_2014$survey.ID=='2014.16') #& data_2014$status=='alive') #get rid of '0' values for minimum
data_trees <- data_2014[!duplicated(data_2014["sp"]),]
data_trees <- data_trees[c("sp")] #list that shows all sp alive and dead
#make data.frames with the dbhmax,min,mean by sp
data_surveys$dbh <- as.numeric(data_surveys$dbh)
dbhmax <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), max)
dbhmin <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), min)
dbhavg <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), mean)
names(dbhmax) <- c("sp", "dbhmax.mm")
names(dbhmin) <- c("sp", "dbhmin.mm")
names(dbhavg) <- c("sp", "dbhavg.mm")
is.num <- sapply(dbhavg,is.numeric)
dbhavg[is.num] <- lapply(dbhavg[is.num], round, 1)
#create data.frame with count of sp per survey
library(data.table)
data_01<-subset(data_2014,data_2014$survey.ID=='2014.16') #get all sp
countbi<- addmargins(table(data_01$sp, data_01$biannual),1)
countbi<- as.data.frame.matrix(countbi)
setDT(countbi, keep.rownames=TRUE)[]
colnames(countbi) <- c("sp", "biannual.n")
countintra<- addmargins(table(data_01$sp, data_01$intraannual==1), 1)
countintra<- as.data.frame.matrix(countintra)
setDT(countintra, keep.rownames=TRUE)[]
colnames(countintra) <- c("sp", "wrong", "intraannual.n")
countintra$wrong <- NULL
#merge the data.frames together
library(tidyverse)
#have to make two separate dataframes, then merge them together to make sure the "Sum" row is kept
data_count <- merge(countbi, countintra, by="sp")
data_num <- list(data_trees,dbhmin,dbhmax,dbhavg) %>% reduce(left_join, by="sp")
data_merged <- merge(data_count, data_num, by="sp", all.x=TRUE)
data_merged <- data_merged[order(data_merged$sp),]
data_2014 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/2014/scbi.dendroAll_2014.csv")
#subset by the last survey from the year
data_surveys<- subset(data_2014,data_2014$survey.ID=='2014.14') #& data_2014$status=='alive') #get rid of '0' values for minimum
data_trees <- data_2014[!duplicated(data_2014["sp"]),]
data_trees <- data_trees[c("sp")] #list that shows all sp alive and dead
#make data.frames with the dbhmax,min,mean by sp
data_surveys$dbh <- as.numeric(data_surveys$dbh)
dbhmax <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), max)
dbhmin <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), min)
dbhavg <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), mean)
names(dbhmax) <- c("sp", "dbhmax.mm")
names(dbhmin) <- c("sp", "dbhmin.mm")
names(dbhavg) <- c("sp", "dbhavg.mm")
is.num <- sapply(dbhavg,is.numeric)
dbhavg[is.num] <- lapply(dbhavg[is.num], round, 1)
#create data.frame with count of sp per survey
library(data.table)
data_01<-subset(data_2014,data_2014$survey.ID=='2014.01') #get all sp
countbi<- addmargins(table(data_01$sp, data_01$biannual),1)
countbi<- as.data.frame.matrix(countbi)
setDT(countbi, keep.rownames=TRUE)[]
colnames(countbi) <- c("sp", "biannual.n")
countintra<- addmargins(table(data_01$sp, data_01$intraannual==1), 1)
countintra<- as.data.frame.matrix(countintra)
setDT(countintra, keep.rownames=TRUE)[]
colnames(countintra) <- c("sp", "wrong", "intraannual.n")
countintra$wrong <- NULL
#merge the data.frames together
library(tidyverse)
#have to make two separate dataframes, then merge them together to make sure the "Sum" row is kept
data_count <- merge(countbi, countintra, by="sp")
data_num <- list(data_trees,dbhmin,dbhmax,dbhavg) %>% reduce(left_join, by="sp")
data_merged <- merge(data_count, data_num, by="sp", all.x=TRUE)
data_merged <- data_merged[order(data_merged$sp),]
View(data_merged)
##reorder to make "Sum" row be last. These numbers may change depending on if a tree has been fully removed from the survey
data_merged <- data_merged[c(1:22,24,25,23),]
View(data_merged)
data_2013 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/2013/scbi.dendroAll_2013.csv")
#subset by the last survey from the year
data_surveys<- subset(data_2013,data_2013$survey.ID=='2013.16') #& data_2013$status=='alive') #get rid of '0' values for minimum
data_trees <- data_2013[!duplicated(data_2013["sp"]),]
data_trees <- data_trees[c("sp")] #list that shows all sp alive and dead
#make data.frames with the dbhmax,min,mean by sp
data_surveys$dbh <- as.numeric(data_surveys$dbh)
dbhmax <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), max)
dbhmin <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), min)
dbhavg <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), mean)
names(dbhmax) <- c("sp", "dbhmax.mm")
names(dbhmin) <- c("sp", "dbhmin.mm")
names(dbhavg) <- c("sp", "dbhavg.mm")
is.num <- sapply(dbhavg,is.numeric)
dbhavg[is.num] <- lapply(dbhavg[is.num], round, 1)
#create data.frame with count of sp per survey
library(data.table)
data_01<-subset(data_2013,data_2013$survey.ID=='2013.16') #get all sp
countbi<- addmargins(table(data_01$sp, data_01$biannual),1)
countbi<- as.data.frame.matrix(countbi)
setDT(countbi, keep.rownames=TRUE)[]
colnames(countbi) <- c("sp", "biannual.n")
countintra<- addmargins(table(data_01$sp, data_01$intraannual==1), 1)
countintra<- as.data.frame.matrix(countintra)
setDT(countintra, keep.rownames=TRUE)[]
colnames(countintra) <- c("sp", "wrong", "intraannual.n")
countintra$wrong <- NULL
#merge the data.frames together
library(tidyverse)
#have to make two separate dataframes, then merge them together to make sure the "Sum" row is kept
data_count <- merge(countbi, countintra, by="sp")
data_num <- list(data_trees,dbhmin,dbhmax,dbhavg) %>% reduce(left_join, by="sp")
data_merged <- merge(data_count, data_num, by="sp", all.x=TRUE)
data_merged <- data_merged[order(data_merged$sp),]
##reorder to make "Sum" row be last. These numbers may change depending on if a tree has been fully removed from the survey
data_merged <- data_merged[c(1:22,24,25,23),]
View(data_merged)
data_2013 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/2013/scbi.dendroAll_2013.csv")
#subset by the last survey from the year
data_surveys<- subset(data_2013,data_2013$survey.ID=='2013.16') #& data_2013$status=='alive') #get rid of '0' values for minimum
data_trees <- data_2013[!duplicated(data_2013["sp"]),]
data_trees <- data_trees[c("sp")] #list that shows all sp alive and dead
#make data.frames with the dbhmax,min,mean by sp
data_surveys$dbh <- as.numeric(data_surveys$dbh)
dbhmax <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), max)
dbhmin <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), min)
dbhavg <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), mean)
names(dbhmax) <- c("sp", "dbhmax.mm")
names(dbhmin) <- c("sp", "dbhmin.mm")
names(dbhavg) <- c("sp", "dbhavg.mm")
is.num <- sapply(dbhavg,is.numeric)
dbhavg[is.num] <- lapply(dbhavg[is.num], round, 1)
#create data.frame with count of sp per survey
library(data.table)
data_01<-subset(data_2013,data_2013$survey.ID=='2013.16') #get all sp
countbi<- addmargins(table(data_01$sp, data_01$biannual),1)
countbi<- as.data.frame.matrix(countbi)
setDT(countbi, keep.rownames=TRUE)[]
colnames(countbi) <- c("sp", "biannual.n")
countintra<- addmargins(table(data_01$sp, data_01$intraannual==1), 1)
countintra<- as.data.frame.matrix(countintra)
setDT(countintra, keep.rownames=TRUE)[]
colnames(countintra) <- c("sp", "wrong", "intraannual.n")
countintra$wrong <- NULL
#merge the data.frames together
library(tidyverse)
#have to make two separate dataframes, then merge them together to make sure the "Sum" row is kept
data_count <- merge(countbi, countintra, by="sp")
data_num <- list(data_trees,dbhmin,dbhmax,dbhavg) %>% reduce(left_join, by="sp")
data_merged <- merge(data_count, data_num, by="sp", all.x=TRUE)
data_merged <- data_merged[order(data_merged$sp),]
View(data_merged)
##reorder to make "Sum" row be last. These numbers may change depending on if a tree has been fully removed from the survey
data_merged <- data_merged[c(1:21,23,24,22),]
write.csv(data_merged, "dendro_trees_sp_2013_min_max_mean_dbh.csv", row.names=FALSE)
data_2014 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/2014/scbi.dendroAll_2014.csv")
#subset by the last survey from the year
data_surveys<- subset(data_2014,data_2014$survey.ID=='2014.14') #& data_2014$status=='alive') #get rid of '0' values for minimum
data_trees <- data_2014[!duplicated(data_2014["sp"]),]
data_trees <- data_trees[c("sp")] #list that shows all sp alive and dead
#make data.frames with the dbhmax,min,mean by sp
data_surveys$dbh <- as.numeric(data_surveys$dbh)
dbhmax <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), max)
dbhmin <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), min)
dbhavg <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), mean)
names(dbhmax) <- c("sp", "dbhmax.mm")
names(dbhmin) <- c("sp", "dbhmin.mm")
names(dbhavg) <- c("sp", "dbhavg.mm")
is.num <- sapply(dbhavg,is.numeric)
dbhavg[is.num] <- lapply(dbhavg[is.num], round, 1)
#create data.frame with count of sp per survey
library(data.table)
data_01<-subset(data_2014,data_2014$survey.ID=='2014.01') #get all sp
countbi<- addmargins(table(data_01$sp, data_01$biannual),1)
countbi<- as.data.frame.matrix(countbi)
setDT(countbi, keep.rownames=TRUE)[]
colnames(countbi) <- c("sp", "biannual.n")
countintra<- addmargins(table(data_01$sp, data_01$intraannual==1), 1)
countintra<- as.data.frame.matrix(countintra)
setDT(countintra, keep.rownames=TRUE)[]
colnames(countintra) <- c("sp", "wrong", "intraannual.n")
countintra$wrong <- NULL
#merge the data.frames together
library(tidyverse)
#have to make two separate dataframes, then merge them together to make sure the "Sum" row is kept
data_count <- merge(countbi, countintra, by="sp")
data_num <- list(data_trees,dbhmin,dbhmax,dbhavg) %>% reduce(left_join, by="sp")
data_merged <- merge(data_count, data_num, by="sp", all.x=TRUE)
data_merged <- data_merged[order(data_merged$sp),]
View(data_merged)
##reorder to make "Sum" row be last. These numbers may change depending on if a tree has been fully removed from the survey
data_merged <- data_merged[c(1:21,23,24,22),]
write.csv(data_merged, "dendro_trees_sp_2014_min_max_mean_dbh.csv", row.names=FALSE)
data_2015 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/2015/scbi.dendroAll_2015.csv")
#subset by the last survey from the year
data_surveys<- subset(data_2015,data_2015$survey.ID=='2015.13') #& data_2015$status=='alive') #get rid of '0' values for minimum
data_trees <- data_2015[!duplicated(data_2015["sp"]),]
data_trees <- data_trees[c("sp")] #list that shows all sp alive and dead
#make data.frames with the dbhmax,min,mean by sp
data_surveys$dbh <- as.numeric(data_surveys$dbh)
dbhmax <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), max)
dbhmin <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), min)
dbhavg <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), mean)
names(dbhmax) <- c("sp", "dbhmax.mm")
names(dbhmin) <- c("sp", "dbhmin.mm")
names(dbhavg) <- c("sp", "dbhavg.mm")
is.num <- sapply(dbhavg,is.numeric)
dbhavg[is.num] <- lapply(dbhavg[is.num], round, 1)
#create data.frame with count of sp per survey
library(data.table)
data_01<-subset(data_2015,data_2015$survey.ID=='2015.01') #get all sp
countbi<- addmargins(table(data_01$sp, data_01$biannual),1)
countbi<- as.data.frame.matrix(countbi)
setDT(countbi, keep.rownames=TRUE)[]
colnames(countbi) <- c("sp", "biannual.n")
countintra<- addmargins(table(data_01$sp, data_01$intraannual==1), 1)
countintra<- as.data.frame.matrix(countintra)
setDT(countintra, keep.rownames=TRUE)[]
colnames(countintra) <- c("sp", "wrong", "intraannual.n")
countintra$wrong <- NULL
#merge the data.frames together
library(tidyverse)
#have to make two separate dataframes, then merge them together to make sure the "Sum" row is kept
data_count <- merge(countbi, countintra, by="sp")
data_num <- list(data_trees,dbhmin,dbhmax,dbhavg) %>% reduce(left_join, by="sp")
data_merged <- merge(data_count, data_num, by="sp", all.x=TRUE)
data_merged <- data_merged[order(data_merged$sp),]
View(data_merged)
##reorder to make "Sum" row be last. These numbers may change depending on if a tree has been fully removed from the survey
data_merged <- data_merged[c(1:21,23,24,22),]
write.csv(data_merged, "dendro_trees_sp_2015_min_max_mean_dbh.csv", row.names=FALSE)
data_2016 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/2016/scbi.dendroAll_2016.csv")
#subset by the last survey from the year
data_surveys<- subset(data_2016,data_2016$survey.ID=='2016.15') #& data_2016$status=='alive') #get rid of '0' values for minimum
data_trees <- data_2016[!duplicated(data_2016["sp"]),]
data_trees <- data_trees[c("sp")] #list that shows all sp alive and dead
#make data.frames with the dbhmax,min,mean by sp
data_surveys$dbh <- as.numeric(data_surveys$dbh)
dbhmax <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), max)
dbhmin <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), min)
dbhavg <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), mean)
names(dbhmax) <- c("sp", "dbhmax.mm")
names(dbhmin) <- c("sp", "dbhmin.mm")
names(dbhavg) <- c("sp", "dbhavg.mm")
is.num <- sapply(dbhavg,is.numeric)
dbhavg[is.num] <- lapply(dbhavg[is.num], round, 1)
#create data.frame with count of sp per survey
library(data.table)
data_01<-subset(data_2016,data_2016$survey.ID=='2016.01') #get all sp
countbi<- addmargins(table(data_01$sp, data_01$biannual),1)
countbi<- as.data.frame.matrix(countbi)
setDT(countbi, keep.rownames=TRUE)[]
colnames(countbi) <- c("sp", "biannual.n")
countintra<- addmargins(table(data_01$sp, data_01$intraannual==1), 1)
countintra<- as.data.frame.matrix(countintra)
setDT(countintra, keep.rownames=TRUE)[]
colnames(countintra) <- c("sp", "wrong", "intraannual.n")
countintra$wrong <- NULL
#merge the data.frames together
library(tidyverse)
#have to make two separate dataframes, then merge them together to make sure the "Sum" row is kept
data_count <- merge(countbi, countintra, by="sp")
data_num <- list(data_trees,dbhmin,dbhmax,dbhavg) %>% reduce(left_join, by="sp")
data_merged <- merge(data_count, data_num, by="sp", all.x=TRUE)
data_merged <- data_merged[order(data_merged$sp),]
View(data_merged)
##reorder to make "Sum" row be last. These numbers may change depending on if a tree has been fully removed from the survey
data_merged <- data_merged[c(1:20,22,23,21),]
write.csv(data_merged, "dendro_trees_sp_2016_min_max_mean_dbh.csv", row.names=FALSE)
data_2017 <- read.csv("C:/Users/mcgregori/Dropbox (Smithsonian)/Github_Ian/Dendrobands/data/2017/scbi.dendroAll_2017.csv")
#subset by the last survey from the year
data_surveys<- subset(data_2017,data_2017$survey.ID=='2017.12') #& data_2017$status=='alive') #get rid of '0' values for minimum
data_trees <- data_2017[!duplicated(data_2017["sp"]),]
data_trees <- data_trees[c("sp")] #list that shows all sp alive and dead
#make data.frames with the dbhmax,min,mean by sp
data_surveys$dbh <- as.numeric(data_surveys$dbh)
dbhmax <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), max)
dbhmin <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), min)
dbhavg <- aggregate(data_surveys$dbh, by=list(data_surveys$sp), mean)
names(dbhmax) <- c("sp", "dbhmax.mm")
names(dbhmin) <- c("sp", "dbhmin.mm")
names(dbhavg) <- c("sp", "dbhavg.mm")
is.num <- sapply(dbhavg,is.numeric)
dbhavg[is.num] <- lapply(dbhavg[is.num], round, 1)
#create data.frame with count of sp per survey
library(data.table)
data_01<-subset(data_2017,data_2017$survey.ID=='2017.01') #get all sp
countbi<- addmargins(table(data_01$sp, data_01$biannual),1)
countbi<- as.data.frame.matrix(countbi)
setDT(countbi, keep.rownames=TRUE)[]
colnames(countbi) <- c("sp", "biannual.n")
countintra<- addmargins(table(data_01$sp, data_01$intraannual==1), 1)
countintra<- as.data.frame.matrix(countintra)
setDT(countintra, keep.rownames=TRUE)[]
colnames(countintra) <- c("sp", "wrong", "intraannual.n")
countintra$wrong <- NULL
#merge the data.frames together
library(tidyverse)
#have to make two separate dataframes, then merge them together to make sure the "Sum" row is kept
data_count <- merge(countbi, countintra, by="sp")
data_num <- list(data_trees,dbhmin,dbhmax,dbhavg) %>% reduce(left_join, by="sp")
data_merged <- merge(data_count, data_num, by="sp", all.x=TRUE)
data_merged <- data_merged[order(data_merged$sp),]
View(data_merged)
##reorder to make "Sum" row be last. These numbers may change depending on if a tree has been fully removed from the survey
data_merged <- data_merged[c(1:20,22,23,21),]
write.csv(data_merged, "dendro_trees_sp_2017_min_max_mean_dbh.csv", row.names=FALSE)
